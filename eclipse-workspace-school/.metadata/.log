!SESSION 2023-02-19 16:04:25.601 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\kgj\eclipse-workspace-school\.metadata\.bak_0.log
Created Time: 2023-02-19 16:40:55.589

!ENTRY org.eclipse.equinox.p2.transport.ecf 2 0 2023-02-19 16:40:55.591
!MESSAGE Connection to http://marketplace.eclipse.org/category/free-tagging/fileExtension_output/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.18 failed on marketplace.eclipse.org. Retry attempt 0 started
!STACK 0
java.net.UnknownHostException: marketplace.eclipse.org
	at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:800)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
	at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
	at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.epp.mpc.ui 4 0 2023-02-19 16:40:55.800
!MESSAGE File support discovery for output failed
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot complete request to http://marketplace.eclipse.org/category/free-tagging/fileExtension_output/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.18: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:200)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:117)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	... 12 more
	Suppressed: org.eclipse.core.runtime.CoreException: Unknown Host: http://marketplace.eclipse.org/category/free-tagging/fileExtension_output/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.18
		at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:196)
		at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:262)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:564)
		at org.eclipse.epp.internal.mpc.core.util.AbstractP2TransportFactory.invokeStream(AbstractP2TransportFactory.java:37)
		at org.eclipse.epp.internal.mpc.core.util.TransportFactory.lambda$0(TransportFactory.java:421)
		at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.primaryFailed(FallbackTransportFactory.java:131)
		at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:91)
		... 13 more
	Caused by: java.net.UnknownHostException: marketplace.eclipse.org
		at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:800)
		at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
		at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
		at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
		at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
		at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
		at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
		at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
		at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
		at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
		at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
		at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
		at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
		... 1 more
Caused by: java.net.UnknownHostException: No such host is known (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	... 14 more
!SUBENTRY 1 org.eclipse.epp.mpc.core 4 0 2023-02-19 16:40:55.800
!MESSAGE Cannot complete request to http://marketplace.eclipse.org/category/free-tagging/fileExtension_output/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.18: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:117)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
	Suppressed: org.eclipse.core.runtime.CoreException: Unknown Host: http://marketplace.eclipse.org/category/free-tagging/fileExtension_output/api/p?client=org.eclipse.epp.mpc.core&os=win32&platform.version=4.18
		at org.eclipse.equinox.internal.p2.transport.ecf.RepositoryTransport.stream(RepositoryTransport.java:196)
		at org.eclipse.oomph.p2.internal.core.CachingTransport.stream(CachingTransport.java:262)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:564)
		at org.eclipse.epp.internal.mpc.core.util.AbstractP2TransportFactory.invokeStream(AbstractP2TransportFactory.java:37)
		at org.eclipse.epp.internal.mpc.core.util.TransportFactory.lambda$0(TransportFactory.java:421)
		at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.primaryFailed(FallbackTransportFactory.java:131)
		at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:91)
		... 13 more
	Caused by: java.net.UnknownHostException: marketplace.eclipse.org
		at java.base/java.net.InetAddress$CachedAddresses.get(InetAddress.java:800)
		at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
		at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
		at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
		at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
		at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
		at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
		at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
		at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
		at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
		at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
		at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
		at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
		at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.performConnect(HttpClientRetrieveFileTransfer.java:1003)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer.access$0(HttpClientRetrieveFileTransfer.java:995)
		at org.eclipse.ecf.provider.filetransfer.httpclient45.HttpClientRetrieveFileTransfer$1.performFileTransfer(HttpClientRetrieveFileTransfer.java:991)
		at org.eclipse.ecf.filetransfer.FileTransferJob.run(FileTransferJob.java:76)
		... 1 more
Caused by: java.net.UnknownHostException: No such host is known (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	... 14 more
Contains: Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
java.net.UnknownHostException: No such host is known (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 2 org.eclipse.epp.mpc.core 4 0 2023-02-19 16:40:55.801
!MESSAGE Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
java.net.UnknownHostException: No such host is known (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 3 org.eclipse.epp.mpc.core 4 0 2023-02-19 16:40:55.801
!MESSAGE Cannot resolve host

This is most often caused by a problem with your internet connection. Please check your internet connection and retry.
!STACK 0
java.net.UnknownHostException: No such host is known (marketplace.eclipse.org)
	at java.base/java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
	at java.base/java.net.InetAddress$PlatformNameService.lookupAllHostAddr(InetAddress.java:932)
	at java.base/java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1517)
	at java.base/java.net.InetAddress$NameServiceAddresses.get(InetAddress.java:851)
	at java.base/java.net.InetAddress.getAllByName0(InetAddress.java:1507)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1366)
	at java.base/java.net.InetAddress.getAllByName(InetAddress.java:1300)
	at org.apache.http.impl.conn.SystemDefaultDnsResolver.resolve(SystemDefaultDnsResolver.java:45)
	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:112)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:374)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:393)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:186)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:56)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:82)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientService.execute(HttpClientService.java:74)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.RequestTemplate.execute(RequestTemplate.java:41)
	at org.eclipse.epp.internal.mpc.core.transport.httpclient.HttpClientTransport.stream(HttpClientTransport.java:102)
	at org.eclipse.epp.internal.mpc.core.util.FallbackTransportFactory$FallbackTransport.stream(FallbackTransportFactory.java:74)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:165)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:130)
	at org.eclipse.epp.internal.mpc.core.service.RemoteMarketplaceService.processRequest(RemoteMarketplaceService.java:117)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.processSearchRequest(DefaultMarketplaceService.java:501)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:528)
	at org.eclipse.epp.internal.mpc.core.service.DefaultMarketplaceService.tagged(DefaultMarketplaceService.java:1)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.lambda$1(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.performSearch(CachingMarketplaceService.java:331)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:312)
	at org.eclipse.epp.internal.mpc.core.service.CachingMarketplaceService.tagged(CachingMarketplaceService.java:318)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:85)
	at org.eclipse.epp.internal.mpc.ui.discovery.DiscoverFileSupportJob.run(DiscoverFileSupportJob.java:69)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-02-22 15:01:47.964 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-02-22 15:01:56.895
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-02-22 15:02:06.332
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-22 15:02:06.332
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb173db,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@26712838,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-22 15:02:20.273
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-02-22 15:02:21.939
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.debug.ui 4 120 2023-02-22 15:18:19.501
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-02-27 11:13:05.780 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-27 11:13:23.306
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-27 11:13:23.307
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14993306,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73ae82da,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 0 2023-02-27 11:13:34.314
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.egit.ui 2 0 2023-02-27 11:13:35.099
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-02-27 15:25:17.148
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;

public class WtLeftHeap<Key extends Comparable<Key>, Value> {
	
	Node root;
	int size;
	
	public class Locator { 
		
		private Node node;
		//private int loc;
		
		private Locator (Node node/*, int loc*/) {
			this.node = node;
			//this.loc = loc;
		}
		
		private Node getNode() {
			return node;
		}
		
		private void setNode(Node node) {
			this.node = node;
		}
		
		/*private int getLoc() {
			return loc;
		}
		
		private void setLoc(int newLoc) {
			loc = newLoc;
		}
		
		public String toString() {
			return loc + "";
		}*/
	}

	public class Node {
		Key key;
		Value val;
		Locator loc;
		Node rightChild;
		Node leftChild;
		int weight;
		
		private Node(Key key, Value val, Locator loc) {
			this.key = key;
			this.val = val;
			this.loc = loc;
			rightChild = null;
			leftChild = null;
		}
		private Key getKey() {
			return key;
		}
		private void setKey(Key key) {
			this.key = key;
		}
		private Value getVal() {
			return val;
		}
		private void setVal(Value val) {
			this.val = val;
		}
		private Locator getLoc() {
			return loc;
		}	
		private void setLoc(Locator loc) {
			this.loc = loc;
		}
	}
	
	public WtLeftHeap() { 
		root = null;
		size - 0}
	public int size() { return size;}
	public void clear() {  }
	public Locator insert(Key x, Value v) { /* ... */ return null; }
	public void mergeWith(WtLeftHeap<Key, Value> h2) { /* ... */ }
	public Value extract() throws Exception { /* ... */ return null; }
	public void updateKey(Locator loc, Key x) throws Exception { /* ... */ }
	public Key peekKey() {  /* ... */ return null; }
	public Value peekValue() { /* ... */ return null; }
	public ArrayList<String> list() { /* ... */ return null; }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-27 15:25:17.154
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-27 15:25:17.155
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-27 15:25:17.168
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;

public class WtLeftHeap<Key extends Comparable<Key>, Value> {
	
	Node root;
	int size;
	
	public class Locator { 
		
		private Node node;
		//private int loc;
		
		private Locator (Node node/*, int loc*/) {
			this.node = node;
			//this.loc = loc;
		}
		
		private Node getNode() {
			return node;
		}
		
		private void setNode(Node node) {
			this.node = node;
		}
		
		/*private int getLoc() {
			return loc;
		}
		
		private void setLoc(int newLoc) {
			loc = newLoc;
		}
		
		public String toString() {
			return loc + "";
		}*/
	}

	public class Node {
		Key key;
		Value val;
		Locator loc;
		Node rightChild;
		Node leftChild;
		int weight;
		
		private Node(Key key, Value val, Locator loc) {
			this.key = key;
			this.val = val;
			this.loc = loc;
			rightChild = null;
			leftChild = null;
		}
		private Key getKey() {
			return key;
		}
		private void setKey(Key key) {
			this.key = key;
		}
		private Value getVal() {
			return val;
		}
		private void setVal(Value val) {
			this.val = val;
		}
		private Locator getLoc() {
			return loc;
		}	
		private void setLoc(Locator loc) {
			this.loc = loc;
		}
	}
	
	public WtLeftHeap() { 
		root = null;
		size - 0}
	public int size() { return size;}
	public void clear() {  }
	public Locator insert(Key x, Value v) { /* ... */ return null; }
	public void mergeWith(WtLeftHeap<Key, Value> h2) { /* ... */ }
	public Value extract() throws Exception { /* ... */ return null; }
	public void updateKey(Locator loc, Key x) throws Exception { /* ... */ }
	public Key peekKey() {  /* ... */ return null; }
	public Value peekValue() { /* ... */ return null; }
	public ArrayList<String> list() { /* ... */ return null; }

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-27 15:25:17.171
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-27 15:25:17.174
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.ui 4 120 2023-02-27 15:55:17.261
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-02-27 17:13:23.962
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-02-27 19:47:23.520
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-03-01 15:05:57.440 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-01 15:06:22.528
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-01 15:06:22.528
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@13d10057,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66944c7c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 0 2023-03-01 15:06:42.097
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.egit.ui 2 0 2023-03-01 15:06:42.535
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.debug.ui 4 120 2023-03-01 16:29:35.412
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-03-08 21:24:14.092 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-08 21:24:27.372
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-08 21:24:27.372
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2cd5b19c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7109b603,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-08 21:24:39.210
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-03-08 21:24:39.319
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.debug.ui 4 120 2023-03-08 22:28:37.488
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-03-08 22:30:56.849
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-03-09 10:59:49.642 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-09 11:00:00.345
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-09 11:00:00.345
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2cd5b19c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7109b603,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 0 2023-03-09 11:00:12.908
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.egit.ui 2 0 2023-03-09 11:00:13.162
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-13 15:50:06.938 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-13 15:50:22.955
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-13 15:50:22.955
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6866e740,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2cd5b19c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 0 2023-03-13 15:50:32.566
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.egit.ui 2 0 2023-03-13 15:50:33.439
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-03-14 16:51:48.652 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-14 16:52:03.233
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-14 16:52:03.233
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6866e740,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2cd5b19c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-14 16:52:15.437
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-03-14 16:52:16.087
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.debug.ui 4 120 2023-03-14 18:20:50.172
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-03-18 11:49:05.204 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-03-18 11:49:22.031
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-03-18 11:49:22.031
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2cd5b19c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7109b603,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-03-18 11:49:41.058
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-03-18 11:49:43.091
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.debug.ui 4 120 2023-03-22 20:24:44.204
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 4 0 2023-03-22 21:14:55.675
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException: Arguments to addParameter(String, String) cannot be null
	at org.apache.commons.httpclient.methods.PostMethod.addParameter(PostMethod.java:299)
	at edu.umd.cs.eclipse.courseProjectManager.TurninProjectAction.getSubmitUserFileFromServer(TurninProjectAction.java:719)
	at edu.umd.cs.eclipse.courseProjectManager.TurninProjectAction.getAllProperties(TurninProjectAction.java:564)
	at edu.umd.cs.eclipse.courseProjectManager.TurninProjectAction.run(TurninProjectAction.java:300)
	at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:239)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4026)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3626)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.debug.ui 4 120 2023-03-22 22:28:39.354
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-03-23 12:10:58.815
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-03-23 16:46:40.229
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-03-23 21:54:10.764
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-24 15:57:16.302
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.annotation.Target cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:162)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:229)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2624)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:5081)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:1667)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:1661)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedJavaBaseType(LookupEnvironment.java:1674)
	at org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding.buildTargetAnnotation(AnnotationBinding.java:134)
	at org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding.addStandardAnnotations(AnnotationBinding.java:79)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.retrieveAnnotations(BinaryTypeBinding.java:1736)
	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getAnnotations(ReferenceBinding.java:1054)
	at org.eclipse.jdt.core.dom.TypeBinding.getAnnotations(TypeBinding.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotations(JavadocHover.java:1177)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.addAnnotations(JavadocHover.java:1137)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:745)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-03-24 16:04:09.256
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-24 17:03:53.884
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.annotation.Target cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:162)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:229)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2624)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:5081)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:1667)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:1661)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedJavaBaseType(LookupEnvironment.java:1674)
	at org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding.buildTargetAnnotation(AnnotationBinding.java:134)
	at org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding.addStandardAnnotations(AnnotationBinding.java:79)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.retrieveAnnotations(BinaryTypeBinding.java:1736)
	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getAnnotations(ReferenceBinding.java:1054)
	at org.eclipse.jdt.core.dom.TypeBinding.getAnnotations(TypeBinding.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotations(JavadocHover.java:1177)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.addAnnotations(JavadocHover.java:1137)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:745)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-03-24 17:21:45.757
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-03-24 17:56:59.848
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
org.eclipse.jdt.internal.compiler.problem.AbortCompilation: Pb(324) The type java.lang.annotation.Target cannot be resolved. It is indirectly referenced from required .class files
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:162)
	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:229)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2624)
	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:5081)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:1667)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedType(LookupEnvironment.java:1661)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getResolvedJavaBaseType(LookupEnvironment.java:1674)
	at org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding.buildTargetAnnotation(AnnotationBinding.java:134)
	at org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding.addStandardAnnotations(AnnotationBinding.java:79)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.retrieveAnnotations(BinaryTypeBinding.java:1736)
	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.getAnnotations(ReferenceBinding.java:1054)
	at org.eclipse.jdt.core.dom.TypeBinding.getAnnotations(TypeBinding.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getAnnotations(JavadocHover.java:1177)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.addAnnotations(JavadocHover.java:1137)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:745)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-04-03 14:17:54.309 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-03 14:18:10.408
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-03 14:18:10.408
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6a0c7af6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f1ad846,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-03 14:18:20.470
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-04-03 14:18:22.019
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.debug.ui 4 120 2023-04-03 15:23:34.758
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-04-04 21:16:12.590
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-04-05 22:51:56.994
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-04-06 19:30:14.410
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2023-04-07 17:41:43.270 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-07 17:41:57.485
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-07 17:41:57.485
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5602e540,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@11f9b95a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-07 17:42:06.618
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-04-07 17:42:08.259
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.debug.ui 4 120 2023-04-20 09:53:02.541
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-20 20:40:57.334
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package BranchAndBoundP7;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class BranchAndBound {

	public static void sequence(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\BranchAndBoundP7\\output");
		String word = "";
		while (scan.hasNextLine()) {
			word+=scan.nextLine();
		}
		System.out.println(word);
		
		String[] words = word.split(" ");
		ArrayList<Integer> partPeps = new ArrayList<Integer>();
		for (int i = 0; i < words.length; i++) {
			partPeps.add(Integer.parseInt(words[i]));
		}
		
		ArrayList<Integer> amiAcids = new ArrayList<Integer>();
		int[] tempArray = {57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129,
				131, 137, 147, 156, 163, 186};
	
		for (int i = 0; i < tempArray.length; i++) {
			amiAcids.add(tempArray[i]);
		}
		
		for (int i = amiAcids.size()-1; i >= 0; i--) {
			if (!partPeps.contains(amiAcids.get(i))) {
				amiAcids.remove(i);
			}
		}
		
		
		ArrayList<ArrayList<Integer>> branches = new ArrayList<ArrayList<Integer>>();
		ArrayList<Integer> tempList;
		for (int i = 0; i < amiAcids.size(); i++) {
			tempList = new ArrayList<Integer>();
			tempList.add(amiAcids.get(i));
			branches.add(tempList);
		}
		
		//do branch and bound
		int count = 0;
		while (branches.size()>count) {
			if (branches.get(i).) {
				
			}
		}
		
		System.out.println(partPeps);
		System.out.println(amiAcids);
		System.out.println(branches);
		
		/*ArrayList<Integer> test = new ArrayList<Integer>();
		test.add(1);
		test.add(2);
		test.add(4);
		test.add(8);
		test.add(16);
		System.out.println(linSpec(test));
		System.out.println(linSpec(test).size());
		System.out.println(circSpec(test));
		System.out.println(circSpec(test).size());*/
		
		boolean wrote = false;
		
		writer.write("");
		
		
		
		writer.close();
	}
	
	public static int sum(ArrayList<Integer>)
	
	public static ArrayList<Integer> linSpec(ArrayList<Integer> masses) {
		ArrayList<Integer> spectrum = new ArrayList<Integer>();
		int sum = 0;
		spectrum.add(0);
		for (int i = 1; i < masses.size(); i++) {//lengths needed to check
			for (int j = 0; j <= masses.size()-i; j++) {//how many to check FE length
				for (int k = 0; k < i; k++) {//sum over to make masses
					sum+=masses.get(j+k);
				}
				spectrum.add(sum);
				sum = 0;
			}
		}
		for (int i = 0; i < masses.size(); i++) {
			sum+=masses.get(i);
		}
		spectrum.add(sum);
		Collections.sort(spectrum);
		return spectrum;
	}
	
	public static ArrayList<Integer> circSpec(ArrayList<Integer> masses) {
		ArrayList<Integer> spectrum = new ArrayList<Integer>();
		int sum = 0;
		spectrum.add(0);
		for (int i = 1; i < masses.size(); i++) {//lengths needed to check
			for (int j = 0; j < masses.size(); j++) {//how many to check FE length
				for (int k = 0; k < i; k++) {//sum over to make masses
					sum+=masses.get((j+k)%masses.size());
				}
				spectrum.add(sum);
				sum = 0;
			}
		}
		for (int i = 0; i < masses.size(); i++) {
			sum+=masses.get(i);
		}
		spectrum.add(sum);
		Collections.sort(spectrum);
		return spectrum;
	}
	
	public static void main(String[] args) {
		//File input1 = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\BranchAndBoundP7\\TestInput");
		//System.out.println("Hi");
		try {
			sequence(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-20 20:40:57.344
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-20 20:40:57.347
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-04-20 20:40:59.919
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package BranchAndBoundP7;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class BranchAndBound {

	public static void sequence(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\BranchAndBoundP7\\output");
		String word = "";
		while (scan.hasNextLine()) {
			word+=scan.nextLine();
		}
		System.out.println(word);
		
		String[] words = word.split(" ");
		ArrayList<Integer> partPeps = new ArrayList<Integer>();
		for (int i = 0; i < words.length; i++) {
			partPeps.add(Integer.parseInt(words[i]));
		}
		
		ArrayList<Integer> amiAcids = new ArrayList<Integer>();
		int[] tempArray = {57, 71, 87, 97, 99, 101, 103, 113, 114, 115, 128, 129,
				131, 137, 147, 156, 163, 186};
	
		for (int i = 0; i < tempArray.length; i++) {
			amiAcids.add(tempArray[i]);
		}
		
		for (int i = amiAcids.size()-1; i >= 0; i--) {
			if (!partPeps.contains(amiAcids.get(i))) {
				amiAcids.remove(i);
			}
		}
		
		
		ArrayList<ArrayList<Integer>> branches = new ArrayList<ArrayList<Integer>>();
		ArrayList<Integer> tempList;
		for (int i = 0; i < amiAcids.size(); i++) {
			tempList = new ArrayList<Integer>();
			tempList.add(amiAcids.get(i));
			branches.add(tempList);
		}
		
		//do branch and bound
		int count = 0;
		while (branches.size()>count) {
			if (branches.get(i).) {
				
			}
		}
		
		System.out.println(partPeps);
		System.out.println(amiAcids);
		System.out.println(branches);
		
		/*ArrayList<Integer> test = new ArrayList<Integer>();
		test.add(1);
		test.add(2);
		test.add(4);
		test.add(8);
		test.add(16);
		System.out.println(linSpec(test));
		System.out.println(linSpec(test).size());
		System.out.println(circSpec(test));
		System.out.println(circSpec(test).size());*/
		
		boolean wrote = false;
		
		writer.write("");
		
		
		
		writer.close();
	}
	
	public static int sum(ArrayList<Integer> masses)
	
	public static ArrayList<Integer> linSpec(ArrayList<Integer> masses) {
		ArrayList<Integer> spectrum = new ArrayList<Integer>();
		int sum = 0;
		spectrum.add(0);
		for (int i = 1; i < masses.size(); i++) {//lengths needed to check
			for (int j = 0; j <= masses.size()-i; j++) {//how many to check FE length
				for (int k = 0; k < i; k++) {//sum over to make masses
					sum+=masses.get(j+k);
				}
				spectrum.add(sum);
				sum = 0;
			}
		}
		for (int i = 0; i < masses.size(); i++) {
			sum+=masses.get(i);
		}
		spectrum.add(sum);
		Collections.sort(spectrum);
		return spectrum;
	}
	
	public static ArrayList<Integer> circSpec(ArrayList<Integer> masses) {
		ArrayList<Integer> spectrum = new ArrayList<Integer>();
		int sum = 0;
		spectrum.add(0);
		for (int i = 1; i < masses.size(); i++) {//lengths needed to check
			for (int j = 0; j < masses.size(); j++) {//how many to check FE length
				for (int k = 0; k < i; k++) {//sum over to make masses
					sum+=masses.get((j+k)%masses.size());
				}
				spectrum.add(sum);
				sum = 0;
			}
		}
		for (int i = 0; i < masses.size(); i++) {
			sum+=masses.get(i);
		}
		spectrum.add(sum);
		Collections.sort(spectrum);
		return spectrum;
	}
	
	public static void main(String[] args) {
		//File input1 = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\BranchAndBoundP7\\TestInput");
		//System.out.println("Hi");
		try {
			sequence(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-04-20 20:40:59.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-04-20 20:40:59.928
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.debug.ui 4 120 2023-04-20 20:52:17.395
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.e4.ui.workbench.swt 4 2 2023-04-20 20:52:30.934
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench.swt".
!STACK 0
org.eclipse.e4.core.di.InjectionException: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchWindow.getActivePage()" because the return value of "org.eclipse.ui.IWorkbench.getActiveWorkbenchWindow()" is null
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.setEnabled(HandlerServiceHandler.java:84)
	at org.eclipse.core.commands.Command.setEnabled(Command.java:856)
	at org.eclipse.ui.menus.CommandContributionItem.isEnabled(CommandContributionItem.java:916)
	at org.eclipse.ui.menus.CommandContributionItem.updateMenuItem(CommandContributionItem.java:531)
	at org.eclipse.ui.menus.CommandContributionItem.update(CommandContributionItem.java:484)
	at org.eclipse.ui.menus.CommandContributionItem.update(CommandContributionItem.java:477)
	at org.eclipse.ui.menus.CommandContributionItem.lambda$0(CommandContributionItem.java:935)
	at org.eclipse.jface.bindings.BindingManager.fireBindingManagerChanged(BindingManager.java:903)
	at org.eclipse.jface.bindings.BindingManager.setActiveBindings(BindingManager.java:2183)
	at org.eclipse.jface.bindings.BindingManager.recomputeBindings(BindingManager.java:1769)
	at org.eclipse.jface.bindings.BindingManager.contextManagerChanged(BindingManager.java:693)
	at org.eclipse.core.commands.contexts.ContextManager.fireContextManagerChanged(ContextManager.java:164)
	at org.eclipse.core.commands.contexts.ContextManager.setActiveContextIds(ContextManager.java:295)
	at org.eclipse.e4.ui.services.ContextServiceAddon$1.changed(ContextServiceAddon.java:49)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:379)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.activate(EclipseContext.java:683)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.activateBranch(EclipseContext.java:692)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener$1.run(ShellActivationListener.java:99)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener.processWindow(ShellActivationListener.java:95)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener.handleEvent(ShellActivationListener.java:65)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1268)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Decorations.WM_ACTIVATE(Decorations.java:1521)
	at org.eclipse.swt.widgets.Shell.WM_ACTIVATE(Shell.java:2170)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4759)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DestroyWindow(Native Method)
	at org.eclipse.swt.widgets.Control.destroyWidget(Control.java:786)
	at org.eclipse.swt.widgets.Shell.destroyWidget(Shell.java:710)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:804)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.disposeWidget(SWTPartRenderer.java:173)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:942)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:865)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:849)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2095)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1726)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1751)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1751)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1760)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$2(WorkbenchWindow.java:503)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:578)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:269)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1552)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4764)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchWindow.getActivePage()" because the return value of "org.eclipse.ui.IWorkbench.getActiveWorkbenchWindow()" is null
	at org.eclipse.lsp4e.operations.rename.LSPRenameHandler.setEnabled(LSPRenameHandler.java:106)
	at org.eclipse.ui.internal.handlers.HandlerProxy.setEnabled(HandlerProxy.java:229)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.setEnabled(E4HandlerProxy.java:133)
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 108 more

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.151
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.157
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.162
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.168
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.175
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.180
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.186
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.190
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.195
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui 4 0 2023-04-20 21:03:10.200
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException: Cannot invoke "java.util.List.size()" because "this.fFilteredProposals" is null
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:863)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Table.checkData(Table.java:1157)
	at org.eclipse.swt.widgets.Table.wmNotifyChild(Table.java:6598)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2142)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:588)
	at org.eclipse.swt.widgets.Table.callWindowProc(Table.java:454)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4863)
	at org.eclipse.swt.widgets.Table.windowProc(Table.java:5813)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.ole.win32.COM.VtblCall(Native Method)
	at org.eclipse.swt.internal.ole.win32.IOleInPlaceObject.InPlaceDeactivate(IOleInPlaceObject.java:24)
	at org.eclipse.swt.ole.win32.OleClientSite.deactivateInPlaceClient(OleClientSite.java:595)
	at org.eclipse.swt.ole.win32.OleClientSite.onDispose(OleClientSite.java:941)
	at org.eclipse.swt.ole.win32.OleClientSite.access$1(OleClientSite.java:928)
	at org.eclipse.swt.ole.win32.OleClientSite$1.handleEvent(OleClientSite.java:130)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:921)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:168)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:713)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1315)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:797)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.AbstractInformationControl.dispose(AbstractInformationControl.java:500)
	at org.eclipse.jface.text.AbstractInformationControlManager.disposeInformationControl(AbstractInformationControlManager.java:1278)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController.disposeInformationControl(AdditionalInfoController.java:501)
	at org.eclipse.jface.text.AbstractInformationControlManager.handleSubjectControlDisposed(AbstractInformationControlManager.java:647)
	at org.eclipse.jface.text.AbstractInformationControlManager.lambda$0(AbstractInformationControlManager.java:682)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1042)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:794)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:410)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:392)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeProposals(AsyncCompletionProposalPopup.java:304)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1508)
	at org.eclipse.jface.text.contentassist.AsyncCompletionProposalPopup.computeFilteredProposals(AsyncCompletionProposalPopup.java:328)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:365)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.getSelectedProposal(CompletionProposalPopup.java:924)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1381)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:811)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:481)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:760)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6099)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5793)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1513)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4884)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4762)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.jface 2 0 2023-04-20 21:07:24.249
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-20 21:07:24.249
!MESSAGE A conflict occurred for F5:
Binding(F5,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.StepInto,Step Into,
		Step into,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59e229fb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(F5,
	ParameterizedCommand(Command(org.eclipse.ui.file.refresh,Refresh,
		Refresh the selected items,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@17d478aa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(F5,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.StepInto,Step Into,
		Step into,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@59e229fb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	basheditor.editors.BashEditor.context,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-20 21:07:24.249
!MESSAGE A conflict occurred for F6:
Binding(F6,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.StepOver,Step Over,
		Step over,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ed651a5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(F6,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.StepOver,Step Over,
		Step over,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ed651a5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	basheditor.editors.BashEditor.context,,,system)
!SESSION 2023-04-24 17:23:09.500 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-24 17:23:25.960
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-24 17:23:25.960
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@460e5ffe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1a4cbcc6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-24 17:23:39.376
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-04-24 17:23:40.171
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.debug.ui 4 120 2023-04-24 17:25:16.379
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.ui 4 10001 2023-04-24 17:25:18.781
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [sequence(File) [in LloydsAlgorithm [in [Working copy] LloydsAlgorithm.java [in LloydsAlgorithmP8 [in src [in CMSC423]]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:573)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:616)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:326)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:312)
	at org.eclipse.jdt.internal.core.SourceRefElement.getSourceRange(SourceRefElement.java:233)
	at org.eclipse.jdt.internal.core.Member.getJavadocRange(Member.java:301)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:515)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-04-24 17:25:18.782
!MESSAGE sequence(File) [in LloydsAlgorithm [in [Working copy] LloydsAlgorithm.java [in LloydsAlgorithmP8 [in src [in CMSC423]]]]] does not exist

!ENTRY org.eclipse.debug.ui 4 120 2023-05-03 16:10:50.704
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:17:50.176
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix()
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:17:50.181
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:17:50.184
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:17:54.216
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix(double[])
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:17:54.218
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:17:54.220
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:17:57.236
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix(double[][])
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:17:57.238
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:17:57.239
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:18:00.260
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix(double[][] matrix)
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:18:00.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:18:00.266
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:18:03.292
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix(double[][] )
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:18:03.295
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:18:03.298
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:18:11.828
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix(double[][] oldMatrix)
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:18:11.830
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:18:11.832
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:18:13.355
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix(double[][] oldMatrix, int)
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:18:13.358
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:18:13.360
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:18:29.395
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix(double[][] oldMatrix, int row)
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:18:29.399
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:18:29.403
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:18:31.929
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			matrix = fixMatrix(matrix, comb1, comb2);
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public double[][] fixMatrix(double[][] oldMatrix, int row, int col)
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:18:31.934
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:18:31.938
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:16.322
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll()
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:16.323
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:16.324
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:34.358
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:34.362
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:34.365
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:37.388
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double matrix)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:37.390
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:37.392
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:43.928
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double matrix,)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:43.933
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:43.937
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:45.962
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:45.966
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:45.969
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:47.012
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][])
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:47.015
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:47.018
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:50.533
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:50.535
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:50.537
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:53.559
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, double)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:53.562
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:53.565
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:56.079
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, int)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:56.081
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:56.083
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:58.108
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, int weights)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:58.112
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:58.116
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:55:59.635
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, int weights:)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:55:59.638
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:55:59.640
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:56:01.663
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, int weights,)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:56:01.665
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:56:01.667
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:56:04.203
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, int[] weights,)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:56:04.210
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:56:04.211
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:56:05.728
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, int[] weights, )
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:56:05.730
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:56:05.731
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:56:07.253
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, int[] weights, String)
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:56:07.260
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:56:07.263
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-03 16:56:08.285
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package HierarchicalClusteringP9;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Scanner;

public class HierarchicalClustering {

	public void cluster(File input) throws IOException {
		Scanner scan = new Scanner(input);
		//FileWriter writer = new FileWriter("output"); //use for submission
		FileWriter writer = new FileWriter("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\output");
		String firstWord = "";
		boolean first = true;
		ArrayList<String> matrixWords = new ArrayList<String>();
		while (scan.hasNextLine()) {
			if (first) {
				firstWord = scan.nextLine();
				first = false;
			} else {
				matrixWords.add(scan.nextLine());
			}
		}
		int nSize = Integer.parseInt(firstWord);
		double[][] matrix = new double[nSize][nSize];
		String[] matrixWordLine;
		for (int i = 0; i < matrixWords.size(); i++) {
			matrixWordLine = matrixWords.get(i).split(" ");
			for (int j = 0; j < matrixWordLine.length; j ++) {
				matrix[i][j] = Double.parseDouble(matrixWordLine[j]);
			}
		}
		
		/*for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		
		int temp = findMinIndex(matrix);
		String[] combos = new String[nSize];
		int[] weights = new int[nSize];
		for (int i = 0; i < combos.length; i++) {
			combos[i] = ""+(i+1);
			weights[i] = 1;
		}
		
		int comb1 = temp/matrix.length;
		int comb2 = temp%matrix.length;
		//System.out.println(comb1 + " " + comb2);
		int count = 1;
		int skip = 0;
		
		/*matrix = fixMatrix(matrix,weights,comb1,comb2);
		
		for (int i = 0; i < matrix.length; i++) {
			for (int j = 0; j < matrix[i].length; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}*/
		while (matrix.length>1) {
			if (count != 1) {
				writer.write("\n");
			}
			temp = findMinIndex(matrix);
			comb1 = (temp/matrix.length<temp%matrix.length)?(temp/matrix.length):(temp%matrix.length);
			comb2 = (temp/matrix.length<temp%matrix.length)?(temp%matrix.length):(temp/matrix.length);
			//String tempCombo = combos[comb1] + " " + combos[comb2];
			
			matrix = fixMatrix(matrix, weights, comb1, comb2);
			
			for (int i = 0; i < combos.length-count; i++) {
				if (i == comb1) {
					weights[i] += weights[comb2];
					combos[i] = combos[comb1] + " " + combos[comb2];
					writer.write(combos[i]);
				} else {
					if (i == comb2) {
						skip++;
					}
					weights[i] = weights[i+skip];
					combos[i] = combos[i+skip];
				}
			}
			
			skip = 0;
			count++;
		}
		
		/*
		 * start
		 * 	findMinIndex row x col = temp/matrix.length x temp%matrix.length
		 * 	write combined letters from combo
		 * 	combine letters in combos
		 * 	combine and rebuild matrix
		 * loop
		 */
		
		
		writer.close();
	}	
	
	public static void printAll(double[][] matrix, int[] weights, String[])
	
	public static double[][] fixMatrix(double[][] oldMatrix, int[] weights, int row, int col) {
		double[][] newMatrix = new double[oldMatrix.length-1][oldMatrix.length-1];
		int rowSkip = 0;
		int colSkip = 0;
		for (int i = 0; i < newMatrix.length; i++) {
			if (i == col) {
				rowSkip++;
			}
			for (int j = 0; j < newMatrix[i].length; j++) {
				if (j == col) {
					colSkip++;
				}
				if (i==j) {
					newMatrix[i][j] = 0;
				} else if (i == row) {
					newMatrix[i][j] = (oldMatrix[i][j+colSkip]*weights[i] + 
							oldMatrix[col][j+colSkip]*weights[col])/(weights[i]+weights[col]);
				} else if (j == row) {
					newMatrix[i][j] = (oldMatrix[i+rowSkip][j]*weights[i] + 
							oldMatrix[i+rowSkip][col]*weights[col])/(weights[i]+weights[col]);
				} else {
					newMatrix[i][j] = oldMatrix[i+rowSkip][j+colSkip];
				}
			}
			colSkip = 0;
		}
		
		return newMatrix;
	}
	
	public int findMinIndex(double[][] matrix) {
		if (matrix.length <= 1) {
			return 0;
		}
		int minIndex = 1;
		double minVal = matrix[0][1];
		int count = 2;
		while (count < matrix.length*matrix.length) {
			if (count%(matrix.length+1)!=0) {
				if (matrix[count/matrix.length][count%matrix.length]<minVal) {
					minIndex = count;
					minVal = matrix[count/matrix.length][count%matrix.length];
				}
			} else {
				//do nothing we are on the diagonal
			}
			count++;
		}
		return minIndex;
	}
	
	public static void main(String[] args) {
		//File input = new File("input"); //use for submission
		File input = new File("C:\\Users\\kgj\\eclipse-workspace-school\\CMSC423\\src\\HierarchicalClusteringP9\\TestInput");
		//System.out.println("Hi");
		try {
			HierarchicalClustering test = new HierarchicalClustering();
			test.cluster(input);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//System.out.println("Hi");
	}
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-03 16:56:08.289
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-03 16:56:08.292
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3146)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:725)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2023-05-04 19:57:34.763 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-05-04 19:57:48.770
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-04 19:57:48.770
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47d9c01,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5358c8fa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 0 2023-05-04 19:57:58.960
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.

!ENTRY org.eclipse.egit.ui 2 0 2023-05-04 19:57:59.133
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2023-05-17 14:08:01.848
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [Node [in [Working copy] SMkdTreeMe.java [in cmsc420_s23 [in <project root> [in Part3-Skeleton]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:573)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:616)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:326)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:312)
	at org.eclipse.jdt.internal.core.SourceRefElement.getSourceRange(SourceRefElement.java:233)
	at org.eclipse.jdt.internal.core.Member.getJavadocRange(Member.java:301)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:515)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-05-17 14:08:01.855
!MESSAGE Node [in [Working copy] SMkdTreeMe.java [in cmsc420_s23 [in <project root> [in Part3-Skeleton]]]] does not exist

!ENTRY org.eclipse.jdt.ui 4 10001 2023-05-17 14:10:06.912
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [ode [in [Working copy] SMkdTreeMe.java [in cmsc420_s23 [in <project root> [in Part3-Skeleton]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:573)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:616)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:326)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:312)
	at org.eclipse.jdt.internal.core.SourceRefElement.getSourceRange(SourceRefElement.java:233)
	at org.eclipse.jdt.internal.core.Member.getJavadocRange(Member.java:301)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:639)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:515)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-05-17 14:10:06.913
!MESSAGE ode [in [Working copy] SMkdTreeMe.java [in cmsc420_s23 [in <project root> [in Part3-Skeleton]]]] does not exist

!ENTRY org.eclipse.jdt.core 4 4 2023-05-17 14:29:24.166
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

public class SMkdTreeMe<LPoint extends LabeledPoint2D> {
		
	private final int REBUILDOFFSET;
	private Rectangle2D rootCell;
	private Node root;
	private int deleteCount;
	
	private abstract class Node {
		private LinkedList<LPoint> contenders;
		abstract LPoint findNode(Point2D q);
		abstract Node insertNode(LPoint pt, Rectangle2D cell) throws Exception;
		abstract Node deleteNode(Point2D pt);
		abstract int size();
		abstract boolean inNode();
		abstract LPoint leftMostPoint();
		abstract ArrayList<String> listNodes();
		abstract ArrayList<LPoint> getPointList();
		public String toString() {
			return "";
		}
		abstract void addCenter(LPoint center);
		abstract ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint);
		abstract Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception;
	}
	
	private class ByXThenY implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(0)!=pt2.get(0)) {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			} else {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			}
		}
	}
	private class ByYThenX implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(1)!=pt2.get(1)) {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			} else {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			}
		}
	}
	
	public double min4(double a, double b, double c, double d) {
		return (a<b):((a<c)?()
	}
	
	private class InternalNode extends Node {
		int cutDim;
		double cutVal;
		Node left, right;
		int size; //n counter from slides (Lect12)
		int insertionCounter; //m counter from slides (Lect12)
		Rectangle2D cell;
		double rMin;
		
		void addCenter(LPoint center) {
			if (cell.contains(center.getPoint2D())) {
				double tempMin;
			}
				
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			
			//create cells based on value of cutDim
			Rectangle2D lcell = new Rectangle2D(cell.low,
					(cutDim==0?new Point2D(cutVal,cell.high.get(cutDim==0?1:0))
							:new Point2D(cell.high.get(cutDim==0?1:0),cutVal)));
			Rectangle2D rcell = new Rectangle2D((cutDim==0? 
					new Point2D(cutVal,cell.low.get(cutDim==0?1:0))
							:new Point2D(cell.low.get(cutDim==0?1:0),cutVal)),
									cell.high);
			
			
			if (bestPoint.size() == 0) {
				// if size == 0 we must call nearestNeighbor on one subtree 
				// and then potentially on the other
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					bestPoint = left.nearestNeighborNode(center, bestPoint);//rec1 //rec4
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
					}
				} else {
					bestPoint = right.nearestNeighborNode(center, bestPoint);//rec2 //rec3
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						//System.out.println("arrived 2 at cutDim: " + cutDim + " and cutVal: " + cutVal);
						bestPoint = left.nearestNeighborNode(center, bestPoint);
					}
				}
			} else {
				// if size != 0 we might need to call nearestNeighbor on one
				// subtree and if so maybe on the other as well
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						bestPoint = left.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
							bestPoint = right.nearestNeighborNode(center, bestPoint);
						}
					}
				} else {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
							bestPoint = left.nearestNeighborNode(center, bestPoint);
						}
					}
				}
			}
			return bestPoint;
			
			
			
		}
		
		Node deleteNode(Point2D pt) {
			if (pt.get(cutDim)<cutVal) {
				Node node = left.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			} else {
				Node node = right.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			}
		}
		
		public String toString() {
			return "{"+left.toString() + "\n[Cut Dim: "+cutDim+"  Cut Val: "+cutVal+
					"   Size: "+size+"   Insertions: "+insertionCounter+"]\n"+
					right.toString()+"}";
		}
		
		boolean inNode() { return true; }
		
		LPoint leftMostPoint() { return left.leftMostPoint(); }
		
		public InternalNode(int cutDim, double cutVal, Rectangle2D cell) {
			this.cutDim = cutDim;
			this.cutVal = cutVal;
			size = 0;
			insertionCounter = 0;
			this.cell = cell;
			this.left = new ExternalNode(null);
			this.right = new ExternalNode(null);
		}
		
		int size() { return size; }
		
		LPoint findNode(Point2D q) {
			if (q.get(cutDim)<cutVal) {
				return left.findNode(q);
			} else {
				return right.findNode(q);
			}
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) {
			//create externalNode if size == 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			}
			if (points.size()==1) {
				return new ExternalNode(points.get(0));
			}
			
			//otherwise have to split into two new cells
			int myDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			Collections.sort(points, (myDim==0?new ByXThenY():new ByYThenX()));
			if (points.get(0).get(myDim)==points.get(points.size()-1).get(myDim)) {
				//degenerate nodes in a line
				myDim = myDim==0?1:0; //switch cutting dimension
			}
			
			double myVal = (cell.getHigh().get(myDim)+cell.getLow().get(myDim))/2;
			if (myVal<points.get(0).get(myDim)) {
				myVal = points.get(0).get(myDim); //slide midpoint
			} else if (myVal>points.get(points.size()-1).get(myDim)) {
				myVal = points.get(points.size()-1).get(myDim); //slide midpoint
			}
			
			//seperate points into new lists
			ArrayList<LPoint> leftPoints = new ArrayList<LPoint>();
			ArrayList<LPoint> rightPoints = new ArrayList<LPoint>();
			for (int i = 0; i < points.size(); i++) {
				if (points.get(i).get(myDim)<myVal) {
					leftPoints.add(points.get(i));
				} else {
					rightPoints.add(points.get(i));
				}
			}
			
			
			Rectangle2D lcell = new Rectangle2D(cell.low,
						(myDim==0?new Point2D(myVal,cell.high.get(myDim==0?1:0))
								:new Point2D(cell.high.get(myDim==0?1:0),myVal)));
			Rectangle2D rcell = new Rectangle2D((myDim==0? 
					new Point2D(myVal,cell.low.get(myDim==0?1:0))
					:new Point2D(cell.low.get(myDim==0?1:0),myVal)),
					cell.high);
			
		
			
			InternalNode returnNode = new InternalNode(myDim, myVal, cell);
			returnNode.left = bulkCreate(leftPoints,lcell);
			returnNode.right = bulkCreate(rightPoints,rcell);
			returnNode.size = points.size();
			
			return returnNode;
			
		}
		
		
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			temp.addAll(left.getPointList());
			temp.addAll(right.getPointList());
			return temp;
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (pt.get(cutDim)<cutVal) {
				left = left.insertNode(pt, cutDim==0?(new Rectangle2D(this.cell.low,
						new Point2D(cutVal,this.cell.high.getY()))):
							(new Rectangle2D(this.cell.low,
									new Point2D(this.cell.high.getX(),cutVal))));
				
			} else {
				right = right.insertNode(pt, cutDim==0?(new Rectangle2D(
						new Point2D(cutVal,this.cell.low.getY()),this.cell.high)):
							(new Rectangle2D(new Point2D(this.cell.low.getX(),cutVal)
									,this.cell.high)));
				
			}
			size++;
			insertionCounter++;
			if (insertionCounter > (size + REBUILDOFFSET)/2) {
				return bulkCreate(getPointList(),cell);
			} else {
				return this;
			}
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			if (cutDim==0)
				retVal.add("(x=" + cutVal + ") " + size + ":" + insertionCounter);
			else
				retVal.add("(y=" + cutVal + ") " + size + ":" + insertionCounter);
			retVal.addAll(right.listNodes());
			retVal.addAll(left.listNodes());
			return retVal;
		}
	}
	
	private class ExternalNode extends Node {
		LPoint point;
		
		void addCenter(LPoint center) {
			
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (point == null) {
				return bestPoint;
			}
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			if(bestPoint.size()==0 ) {
				bestPoint.add(point);
			} else if (bestPoint.get(0).getPoint2D().distance(center)>=point.getPoint2D().distance(center)) {
				if(bestPoint.get(0).getPoint2D().distance(center)==point.getPoint2D().distance(center)) {
					if (bestPoint.get(0).getX()>point.getX()) {
						bestPoint.add(0, point);
					} else if (bestPoint.get(0).getX()==point.getX() &&
							bestPoint.get(0).getY()>point.getY()) {
						//new best point because of lower lexicographic score
						bestPoint.add(0, point);
					} else {
						bestPoint.add(point);
					}
				} else {
					//must be a best point because dist is less than old best
					bestPoint.add(0, point);
				}
			} else {
				bestPoint.add(point);
			}
			return bestPoint;
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception {
			//will only ever be called on a tree of size 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			} 
			return new ExternalNode(points.get(0));
		}
		
		Node deleteNode(Point2D pt) {
			if (point == null) {
				return null;
			} else if (point.getPoint2D().equals(pt)) {
				point = null;
				return this;
			} else {
				return null;
			}
		}
		
		int size() { return point==null?0:1; }
		
		public String toString() {
			if (point != null)
				return "("+point.getX()+", "+point.getY()+") ";
			else
				return "null point";
		}
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			if (point!=null) {
				temp.add(point);
			}
			return temp;
		}
		
		ExternalNode(LPoint point) {
			this.point = point;
		}
		
		boolean inNode() { return false; }
		
		LPoint leftMostPoint() { return point; }
		
		LPoint findNode(Point2D q) {
			if (point == null) {
				return null;
			}
			if (point.getPoint2D().equals(q)) {
				return point;
			} else {
				return null;
			}
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (point == null) {
				point = pt;
				return this;
			}
			if (point.getPoint2D().equals(pt.getPoint2D())) {
				throw new Exception("Insertion of duplicate point");
			}
			//find cutDim
			int cutDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			if (pt.get(cutDim)==point.get(cutDim)) {
				cutDim = cutDim==0?1:0; //if x is cutDim and x's are equal make
				//cutDim Y and vice versa
			}
			
			//find our cutVal
			double cutVal = (cell.high.get(cutDim)+cell.low.get(cutDim))/2;
			double pointVal = point.get(cutDim);
			double ptVal = pt.get(cutDim);
			if (cutVal>pointVal && cutVal>ptVal) {
				cutVal = pointVal>ptVal?pointVal:ptVal;
			} else if (cutVal<pointVal && cutVal<ptVal) {
				cutVal = pointVal<ptVal?pointVal:ptVal;
			}
			
			//create our new internal node
			InternalNode node = new InternalNode(cutDim, cutVal, cell);
			//add our external nodes
			node.insertNode(pt, cell);
			node.insertNode(point, cell);
			node.insertionCounter = 0;
			return node;
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			retVal.add("["+(point==null?"null":point.toString()) + "]");
			return retVal;
		}

		
	}
	
	public SMkdTreeMe(int rebuildOffset, Rectangle2D rootCell) { 
		REBUILDOFFSET = rebuildOffset;
		this.rootCell = rootCell;
		root = new ExternalNode(null);
		deleteCount = 0;
	}
	public void clear() { root = new ExternalNode(null); }
	public int size() { return root==null?0:root.size(); }
	public int deleteCount() { return deleteCount; }
	public LPoint find(Point2D q) { return root.findNode(q); }
	public void insert(LPoint pt) throws Exception { 
		if (!rootCell.contains(pt.getPoint2D()))
			throw new Exception("Attempt to insert a point outside bounding box");
		root = root.insertNode(pt, rootCell);
	}
	public void delete(Point2D pt) throws Exception { 
		Node node = root.deleteNode(pt);
		if (node == null) {
			throw new Exception("Deletion of nonexistent point");
		} else {
			deleteCount++;
			if (deleteCount>size()) {
				root = root.bulkCreate(root.getPointList(),rootCell);
				deleteCount = 0;
			}
		}
	}
	public ArrayList<String> list() { return root.listNodes(); }
	public LPoint nearestNeighbor(Point2D center) { 
		if (size()==0) 
			return null;
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		return points.get(0);
	}
	public ArrayList<LPoint> nearestNeighborVisit(Point2D center) { 
		if (size()==0) 
			return new ArrayList<LPoint>();
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		Collections.sort(points, new ByXThenY());
		return points;
	}

	public String toString() {
		return root.toString();
	}
	
	
	// ----------------------------------------------------------------
	// Possible new additions for Programming Assignment 3
	// You may modify/add/remove these as you see fit, since they will 
	// just be used internally by your code.
	// ----------------------------------------------------------------
	void addCenter(LPoint center) { 
		root.addCenter(center);
	}
	// ArrayList<String> listWithCenters() { /* ... */ return null; }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-17 14:29:24.203
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-17 14:29:24.206
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-17 14:29:24.239
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

public class SMkdTreeMe<LPoint extends LabeledPoint2D> {
		
	private final int REBUILDOFFSET;
	private Rectangle2D rootCell;
	private Node root;
	private int deleteCount;
	
	private abstract class Node {
		private LinkedList<LPoint> contenders;
		abstract LPoint findNode(Point2D q);
		abstract Node insertNode(LPoint pt, Rectangle2D cell) throws Exception;
		abstract Node deleteNode(Point2D pt);
		abstract int size();
		abstract boolean inNode();
		abstract LPoint leftMostPoint();
		abstract ArrayList<String> listNodes();
		abstract ArrayList<LPoint> getPointList();
		public String toString() {
			return "";
		}
		abstract void addCenter(LPoint center);
		abstract ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint);
		abstract Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception;
	}
	
	private class ByXThenY implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(0)!=pt2.get(0)) {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			} else {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			}
		}
	}
	private class ByYThenX implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(1)!=pt2.get(1)) {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			} else {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			}
		}
	}
	
	public double min4(double a, double b, double c, double d) {
		return (a<b):((a<c)?()
	}
	
	private class InternalNode extends Node {
		int cutDim;
		double cutVal;
		Node left, right;
		int size; //n counter from slides (Lect12)
		int insertionCounter; //m counter from slides (Lect12)
		Rectangle2D cell;
		double rMin;
		
		void addCenter(LPoint center) {
			if (cell.contains(center.getPoint2D())) {
				double tempMin;
			}
				
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			
			//create cells based on value of cutDim
			Rectangle2D lcell = new Rectangle2D(cell.low,
					(cutDim==0?new Point2D(cutVal,cell.high.get(cutDim==0?1:0))
							:new Point2D(cell.high.get(cutDim==0?1:0),cutVal)));
			Rectangle2D rcell = new Rectangle2D((cutDim==0? 
					new Point2D(cutVal,cell.low.get(cutDim==0?1:0))
							:new Point2D(cell.low.get(cutDim==0?1:0),cutVal)),
									cell.high);
			
			
			if (bestPoint.size() == 0) {
				// if size == 0 we must call nearestNeighbor on one subtree 
				// and then potentially on the other
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					bestPoint = left.nearestNeighborNode(center, bestPoint);//rec1 //rec4
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
					}
				} else {
					bestPoint = right.nearestNeighborNode(center, bestPoint);//rec2 //rec3
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						//System.out.println("arrived 2 at cutDim: " + cutDim + " and cutVal: " + cutVal);
						bestPoint = left.nearestNeighborNode(center, bestPoint);
					}
				}
			} else {
				// if size != 0 we might need to call nearestNeighbor on one
				// subtree and if so maybe on the other as well
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						bestPoint = left.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
							bestPoint = right.nearestNeighborNode(center, bestPoint);
						}
					}
				} else {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
							bestPoint = left.nearestNeighborNode(center, bestPoint);
						}
					}
				}
			}
			return bestPoint;
			
			
			
		}
		
		Node deleteNode(Point2D pt) {
			if (pt.get(cutDim)<cutVal) {
				Node node = left.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			} else {
				Node node = right.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			}
		}
		
		public String toString() {
			return "{"+left.toString() + "\n[Cut Dim: "+cutDim+"  Cut Val: "+cutVal+
					"   Size: "+size+"   Insertions: "+insertionCounter+"]\n"+
					right.toString()+"}";
		}
		
		boolean inNode() { return true; }
		
		LPoint leftMostPoint() { return left.leftMostPoint(); }
		
		public InternalNode(int cutDim, double cutVal, Rectangle2D cell) {
			this.cutDim = cutDim;
			this.cutVal = cutVal;
			size = 0;
			insertionCounter = 0;
			this.cell = cell;
			this.left = new ExternalNode(null);
			this.right = new ExternalNode(null);
		}
		
		int size() { return size; }
		
		LPoint findNode(Point2D q) {
			if (q.get(cutDim)<cutVal) {
				return left.findNode(q);
			} else {
				return right.findNode(q);
			}
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) {
			//create externalNode if size == 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			}
			if (points.size()==1) {
				return new ExternalNode(points.get(0));
			}
			
			//otherwise have to split into two new cells
			int myDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			Collections.sort(points, (myDim==0?new ByXThenY():new ByYThenX()));
			if (points.get(0).get(myDim)==points.get(points.size()-1).get(myDim)) {
				//degenerate nodes in a line
				myDim = myDim==0?1:0; //switch cutting dimension
			}
			
			double myVal = (cell.getHigh().get(myDim)+cell.getLow().get(myDim))/2;
			if (myVal<points.get(0).get(myDim)) {
				myVal = points.get(0).get(myDim); //slide midpoint
			} else if (myVal>points.get(points.size()-1).get(myDim)) {
				myVal = points.get(points.size()-1).get(myDim); //slide midpoint
			}
			
			//seperate points into new lists
			ArrayList<LPoint> leftPoints = new ArrayList<LPoint>();
			ArrayList<LPoint> rightPoints = new ArrayList<LPoint>();
			for (int i = 0; i < points.size(); i++) {
				if (points.get(i).get(myDim)<myVal) {
					leftPoints.add(points.get(i));
				} else {
					rightPoints.add(points.get(i));
				}
			}
			
			
			Rectangle2D lcell = new Rectangle2D(cell.low,
						(myDim==0?new Point2D(myVal,cell.high.get(myDim==0?1:0))
								:new Point2D(cell.high.get(myDim==0?1:0),myVal)));
			Rectangle2D rcell = new Rectangle2D((myDim==0? 
					new Point2D(myVal,cell.low.get(myDim==0?1:0))
					:new Point2D(cell.low.get(myDim==0?1:0),myVal)),
					cell.high);
			
		
			
			InternalNode returnNode = new InternalNode(myDim, myVal, cell);
			returnNode.left = bulkCreate(leftPoints,lcell);
			returnNode.right = bulkCreate(rightPoints,rcell);
			returnNode.size = points.size();
			
			return returnNode;
			
		}
		
		
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			temp.addAll(left.getPointList());
			temp.addAll(right.getPointList());
			return temp;
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (pt.get(cutDim)<cutVal) {
				left = left.insertNode(pt, cutDim==0?(new Rectangle2D(this.cell.low,
						new Point2D(cutVal,this.cell.high.getY()))):
							(new Rectangle2D(this.cell.low,
									new Point2D(this.cell.high.getX(),cutVal))));
				
			} else {
				right = right.insertNode(pt, cutDim==0?(new Rectangle2D(
						new Point2D(cutVal,this.cell.low.getY()),this.cell.high)):
							(new Rectangle2D(new Point2D(this.cell.low.getX(),cutVal)
									,this.cell.high)));
				
			}
			size++;
			insertionCounter++;
			if (insertionCounter > (size + REBUILDOFFSET)/2) {
				return bulkCreate(getPointList(),cell);
			} else {
				return this;
			}
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			if (cutDim==0)
				retVal.add("(x=" + cutVal + ") " + size + ":" + insertionCounter);
			else
				retVal.add("(y=" + cutVal + ") " + size + ":" + insertionCounter);
			retVal.addAll(right.listNodes());
			retVal.addAll(left.listNodes());
			return retVal;
		}
	}
	
	private class ExternalNode extends Node {
		LPoint point;
		
		void addCenter(LPoint center) {
			
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (point == null) {
				return bestPoint;
			}
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			if(bestPoint.size()==0 ) {
				bestPoint.add(point);
			} else if (bestPoint.get(0).getPoint2D().distance(center)>=point.getPoint2D().distance(center)) {
				if(bestPoint.get(0).getPoint2D().distance(center)==point.getPoint2D().distance(center)) {
					if (bestPoint.get(0).getX()>point.getX()) {
						bestPoint.add(0, point);
					} else if (bestPoint.get(0).getX()==point.getX() &&
							bestPoint.get(0).getY()>point.getY()) {
						//new best point because of lower lexicographic score
						bestPoint.add(0, point);
					} else {
						bestPoint.add(point);
					}
				} else {
					//must be a best point because dist is less than old best
					bestPoint.add(0, point);
				}
			} else {
				bestPoint.add(point);
			}
			return bestPoint;
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception {
			//will only ever be called on a tree of size 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			} 
			return new ExternalNode(points.get(0));
		}
		
		Node deleteNode(Point2D pt) {
			if (point == null) {
				return null;
			} else if (point.getPoint2D().equals(pt)) {
				point = null;
				return this;
			} else {
				return null;
			}
		}
		
		int size() { return point==null?0:1; }
		
		public String toString() {
			if (point != null)
				return "("+point.getX()+", "+point.getY()+") ";
			else
				return "null point";
		}
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			if (point!=null) {
				temp.add(point);
			}
			return temp;
		}
		
		ExternalNode(LPoint point) {
			this.point = point;
		}
		
		boolean inNode() { return false; }
		
		LPoint leftMostPoint() { return point; }
		
		LPoint findNode(Point2D q) {
			if (point == null) {
				return null;
			}
			if (point.getPoint2D().equals(q)) {
				return point;
			} else {
				return null;
			}
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (point == null) {
				point = pt;
				return this;
			}
			if (point.getPoint2D().equals(pt.getPoint2D())) {
				throw new Exception("Insertion of duplicate point");
			}
			//find cutDim
			int cutDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			if (pt.get(cutDim)==point.get(cutDim)) {
				cutDim = cutDim==0?1:0; //if x is cutDim and x's are equal make
				//cutDim Y and vice versa
			}
			
			//find our cutVal
			double cutVal = (cell.high.get(cutDim)+cell.low.get(cutDim))/2;
			double pointVal = point.get(cutDim);
			double ptVal = pt.get(cutDim);
			if (cutVal>pointVal && cutVal>ptVal) {
				cutVal = pointVal>ptVal?pointVal:ptVal;
			} else if (cutVal<pointVal && cutVal<ptVal) {
				cutVal = pointVal<ptVal?pointVal:ptVal;
			}
			
			//create our new internal node
			InternalNode node = new InternalNode(cutDim, cutVal, cell);
			//add our external nodes
			node.insertNode(pt, cell);
			node.insertNode(point, cell);
			node.insertionCounter = 0;
			return node;
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			retVal.add("["+(point==null?"null":point.toString()) + "]");
			return retVal;
		}

		
	}
	
	public SMkdTreeMe(int rebuildOffset, Rectangle2D rootCell) { 
		REBUILDOFFSET = rebuildOffset;
		this.rootCell = rootCell;
		root = new ExternalNode(null);
		deleteCount = 0;
	}
	public void clear() { root = new ExternalNode(null); }
	public int size() { return root==null?0:root.size(); }
	public int deleteCount() { return deleteCount; }
	public LPoint find(Point2D q) { return root.findNode(q); }
	public void insert(LPoint pt) throws Exception { 
		if (!rootCell.contains(pt.getPoint2D()))
			throw new Exception("Attempt to insert a point outside bounding box");
		root = root.insertNode(pt, rootCell);
	}
	public void delete(Point2D pt) throws Exception { 
		Node node = root.deleteNode(pt);
		if (node == null) {
			throw new Exception("Deletion of nonexistent point");
		} else {
			deleteCount++;
			if (deleteCount>size()) {
				root = root.bulkCreate(root.getPointList(),rootCell);
				deleteCount = 0;
			}
		}
	}
	public ArrayList<String> list() { return root.listNodes(); }
	public LPoint nearestNeighbor(Point2D center) { 
		if (size()==0) 
			return null;
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		return points.get(0);
	}
	public ArrayList<LPoint> nearestNeighborVisit(Point2D center) { 
		if (size()==0) 
			return new ArrayList<LPoint>();
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		Collections.sort(points, new ByXThenY());
		return points;
	}

	public String toString() {
		return root.toString();
	}
	
	
	// ----------------------------------------------------------------
	// Possible new additions for Programming Assignment 3
	// You may modify/add/remove these as you see fit, since they will 
	// just be used internally by your code.
	// ----------------------------------------------------------------
	void addCenter(LPoint center) { 
		root.addCenter(center);
	}
	// ArrayList<String> listWithCenters() { /* ... */ return null; }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-17 14:29:24.241
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-17 14:29:24.243
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-17 14:29:24.797
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

public class SMkdTreeMe<LPoint extends LabeledPoint2D> {
		
	private final int REBUILDOFFSET;
	private Rectangle2D rootCell;
	private Node root;
	private int deleteCount;
	
	private abstract class Node {
		private LinkedList<LPoint> contenders;
		abstract LPoint findNode(Point2D q);
		abstract Node insertNode(LPoint pt, Rectangle2D cell) throws Exception;
		abstract Node deleteNode(Point2D pt);
		abstract int size();
		abstract boolean inNode();
		abstract LPoint leftMostPoint();
		abstract ArrayList<String> listNodes();
		abstract ArrayList<LPoint> getPointList();
		public String toString() {
			return "";
		}
		abstract void addCenter(LPoint center);
		abstract ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint);
		abstract Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception;
	}
	
	private class ByXThenY implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(0)!=pt2.get(0)) {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			} else {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			}
		}
	}
	private class ByYThenX implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(1)!=pt2.get(1)) {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			} else {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			}
		}
	}
	
	public double min4(double a, double b, double c, double d) {
		return (a<b):((a<c)?()
	}
	
	private class InternalNode extends Node {
		int cutDim;
		double cutVal;
		Node left, right;
		int size; //n counter from slides (Lect12)
		int insertionCounter; //m counter from slides (Lect12)
		Rectangle2D cell;
		double rMin;
		
		void addCenter(LPoint center) {
			if (cell.contains(center.getPoint2D())) {
				double tempMin;
			}
				
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			
			//create cells based on value of cutDim
			Rectangle2D lcell = new Rectangle2D(cell.low,
					(cutDim==0?new Point2D(cutVal,cell.high.get(cutDim==0?1:0))
							:new Point2D(cell.high.get(cutDim==0?1:0),cutVal)));
			Rectangle2D rcell = new Rectangle2D((cutDim==0? 
					new Point2D(cutVal,cell.low.get(cutDim==0?1:0))
							:new Point2D(cell.low.get(cutDim==0?1:0),cutVal)),
									cell.high);
			
			
			if (bestPoint.size() == 0) {
				// if size == 0 we must call nearestNeighbor on one subtree 
				// and then potentially on the other
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					bestPoint = left.nearestNeighborNode(center, bestPoint);//rec1 //rec4
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
					}
				} else {
					bestPoint = right.nearestNeighborNode(center, bestPoint);//rec2 //rec3
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						//System.out.println("arrived 2 at cutDim: " + cutDim + " and cutVal: " + cutVal);
						bestPoint = left.nearestNeighborNode(center, bestPoint);
					}
				}
			} else {
				// if size != 0 we might need to call nearestNeighbor on one
				// subtree and if so maybe on the other as well
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						bestPoint = left.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
							bestPoint = right.nearestNeighborNode(center, bestPoint);
						}
					}
				} else {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
							bestPoint = left.nearestNeighborNode(center, bestPoint);
						}
					}
				}
			}
			return bestPoint;
			
			
			
		}
		
		Node deleteNode(Point2D pt) {
			if (pt.get(cutDim)<cutVal) {
				Node node = left.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			} else {
				Node node = right.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			}
		}
		
		public String toString() {
			return "{"+left.toString() + "\n[Cut Dim: "+cutDim+"  Cut Val: "+cutVal+
					"   Size: "+size+"   Insertions: "+insertionCounter+"]\n"+
					right.toString()+"}";
		}
		
		boolean inNode() { return true; }
		
		LPoint leftMostPoint() { return left.leftMostPoint(); }
		
		public InternalNode(int cutDim, double cutVal, Rectangle2D cell) {
			this.cutDim = cutDim;
			this.cutVal = cutVal;
			size = 0;
			insertionCounter = 0;
			this.cell = cell;
			this.left = new ExternalNode(null);
			this.right = new ExternalNode(null);
		}
		
		int size() { return size; }
		
		LPoint findNode(Point2D q) {
			if (q.get(cutDim)<cutVal) {
				return left.findNode(q);
			} else {
				return right.findNode(q);
			}
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) {
			//create externalNode if size == 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			}
			if (points.size()==1) {
				return new ExternalNode(points.get(0));
			}
			
			//otherwise have to split into two new cells
			int myDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			Collections.sort(points, (myDim==0?new ByXThenY():new ByYThenX()));
			if (points.get(0).get(myDim)==points.get(points.size()-1).get(myDim)) {
				//degenerate nodes in a line
				myDim = myDim==0?1:0; //switch cutting dimension
			}
			
			double myVal = (cell.getHigh().get(myDim)+cell.getLow().get(myDim))/2;
			if (myVal<points.get(0).get(myDim)) {
				myVal = points.get(0).get(myDim); //slide midpoint
			} else if (myVal>points.get(points.size()-1).get(myDim)) {
				myVal = points.get(points.size()-1).get(myDim); //slide midpoint
			}
			
			//seperate points into new lists
			ArrayList<LPoint> leftPoints = new ArrayList<LPoint>();
			ArrayList<LPoint> rightPoints = new ArrayList<LPoint>();
			for (int i = 0; i < points.size(); i++) {
				if (points.get(i).get(myDim)<myVal) {
					leftPoints.add(points.get(i));
				} else {
					rightPoints.add(points.get(i));
				}
			}
			
			
			Rectangle2D lcell = new Rectangle2D(cell.low,
						(myDim==0?new Point2D(myVal,cell.high.get(myDim==0?1:0))
								:new Point2D(cell.high.get(myDim==0?1:0),myVal)));
			Rectangle2D rcell = new Rectangle2D((myDim==0? 
					new Point2D(myVal,cell.low.get(myDim==0?1:0))
					:new Point2D(cell.low.get(myDim==0?1:0),myVal)),
					cell.high);
			
		
			
			InternalNode returnNode = new InternalNode(myDim, myVal, cell);
			returnNode.left = bulkCreate(leftPoints,lcell);
			returnNode.right = bulkCreate(rightPoints,rcell);
			returnNode.size = points.size();
			
			return returnNode;
			
		}
		
		
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			temp.addAll(left.getPointList());
			temp.addAll(right.getPointList());
			return temp;
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (pt.get(cutDim)<cutVal) {
				left = left.insertNode(pt, cutDim==0?(new Rectangle2D(this.cell.low,
						new Point2D(cutVal,this.cell.high.getY()))):
							(new Rectangle2D(this.cell.low,
									new Point2D(this.cell.high.getX(),cutVal))));
				
			} else {
				right = right.insertNode(pt, cutDim==0?(new Rectangle2D(
						new Point2D(cutVal,this.cell.low.getY()),this.cell.high)):
							(new Rectangle2D(new Point2D(this.cell.low.getX(),cutVal)
									,this.cell.high)));
				
			}
			size++;
			insertionCounter++;
			if (insertionCounter > (size + REBUILDOFFSET)/2) {
				return bulkCreate(getPointList(),cell);
			} else {
				return this;
			}
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			if (cutDim==0)
				retVal.add("(x=" + cutVal + ") " + size + ":" + insertionCounter);
			else
				retVal.add("(y=" + cutVal + ") " + size + ":" + insertionCounter);
			retVal.addAll(right.listNodes());
			retVal.addAll(left.listNodes());
			return retVal;
		}
	}
	
	private class ExternalNode extends Node {
		LPoint point;
		
		void addCenter(LPoint center) {
			
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (point == null) {
				return bestPoint;
			}
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			if(bestPoint.size()==0 ) {
				bestPoint.add(point);
			} else if (bestPoint.get(0).getPoint2D().distance(center)>=point.getPoint2D().distance(center)) {
				if(bestPoint.get(0).getPoint2D().distance(center)==point.getPoint2D().distance(center)) {
					if (bestPoint.get(0).getX()>point.getX()) {
						bestPoint.add(0, point);
					} else if (bestPoint.get(0).getX()==point.getX() &&
							bestPoint.get(0).getY()>point.getY()) {
						//new best point because of lower lexicographic score
						bestPoint.add(0, point);
					} else {
						bestPoint.add(point);
					}
				} else {
					//must be a best point because dist is less than old best
					bestPoint.add(0, point);
				}
			} else {
				bestPoint.add(point);
			}
			return bestPoint;
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception {
			//will only ever be called on a tree of size 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			} 
			return new ExternalNode(points.get(0));
		}
		
		Node deleteNode(Point2D pt) {
			if (point == null) {
				return null;
			} else if (point.getPoint2D().equals(pt)) {
				point = null;
				return this;
			} else {
				return null;
			}
		}
		
		int size() { return point==null?0:1; }
		
		public String toString() {
			if (point != null)
				return "("+point.getX()+", "+point.getY()+") ";
			else
				return "null point";
		}
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			if (point!=null) {
				temp.add(point);
			}
			return temp;
		}
		
		ExternalNode(LPoint point) {
			this.point = point;
		}
		
		boolean inNode() { return false; }
		
		LPoint leftMostPoint() { return point; }
		
		LPoint findNode(Point2D q) {
			if (point == null) {
				return null;
			}
			if (point.getPoint2D().equals(q)) {
				return point;
			} else {
				return null;
			}
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (point == null) {
				point = pt;
				return this;
			}
			if (point.getPoint2D().equals(pt.getPoint2D())) {
				throw new Exception("Insertion of duplicate point");
			}
			//find cutDim
			int cutDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			if (pt.get(cutDim)==point.get(cutDim)) {
				cutDim = cutDim==0?1:0; //if x is cutDim and x's are equal make
				//cutDim Y and vice versa
			}
			
			//find our cutVal
			double cutVal = (cell.high.get(cutDim)+cell.low.get(cutDim))/2;
			double pointVal = point.get(cutDim);
			double ptVal = pt.get(cutDim);
			if (cutVal>pointVal && cutVal>ptVal) {
				cutVal = pointVal>ptVal?pointVal:ptVal;
			} else if (cutVal<pointVal && cutVal<ptVal) {
				cutVal = pointVal<ptVal?pointVal:ptVal;
			}
			
			//create our new internal node
			InternalNode node = new InternalNode(cutDim, cutVal, cell);
			//add our external nodes
			node.insertNode(pt, cell);
			node.insertNode(point, cell);
			node.insertionCounter = 0;
			return node;
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			retVal.add("["+(point==null?"null":point.toString()) + "]");
			return retVal;
		}

		
	}
	
	public SMkdTreeMe(int rebuildOffset, Rectangle2D rootCell) { 
		REBUILDOFFSET = rebuildOffset;
		this.rootCell = rootCell;
		root = new ExternalNode(null);
		deleteCount = 0;
	}
	public void clear() { root = new ExternalNode(null); }
	public int size() { return root==null?0:root.size(); }
	public int deleteCount() { return deleteCount; }
	public LPoint find(Point2D q) { return root.findNode(q); }
	public void insert(LPoint pt) throws Exception { 
		if (!rootCell.contains(pt.getPoint2D()))
			throw new Exception("Attempt to insert a point outside bounding box");
		root = root.insertNode(pt, rootCell);
	}
	public void delete(Point2D pt) throws Exception { 
		Node node = root.deleteNode(pt);
		if (node == null) {
			throw new Exception("Deletion of nonexistent point");
		} else {
			deleteCount++;
			if (deleteCount>size()) {
				root = root.bulkCreate(root.getPointList(),rootCell);
				deleteCount = 0;
			}
		}
	}
	public ArrayList<String> list() { return root.listNodes(); }
	public LPoint nearestNeighbor(Point2D center) { 
		if (size()==0) 
			return null;
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		return points.get(0);
	}
	public ArrayList<LPoint> nearestNeighborVisit(Point2D center) { 
		if (size()==0) 
			return new ArrayList<LPoint>();
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		Collections.sort(points, new ByXThenY());
		return points;
	}

	public String toString() {
		return root.toString();
	}
	
	
	// ----------------------------------------------------------------
	// Possible new additions for Programming Assignment 3
	// You may modify/add/remove these as you see fit, since they will 
	// just be used internally by your code.
	// ----------------------------------------------------------------
	void addCenter(LPoint center) { 
		root.addCenter(center);
	}
	// ArrayList<String> listWithCenters() { /* ... */ return null; }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-17 14:29:24.802
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-17 14:29:24.806
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-17 14:29:27.329
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

public class SMkdTreeMe<LPoint extends LabeledPoint2D> {
		
	private final int REBUILDOFFSET;
	private Rectangle2D rootCell;
	private Node root;
	private int deleteCount;
	
	private abstract class Node {
		private LinkedList<LPoint> contenders;
		abstract LPoint findNode(Point2D q);
		abstract Node insertNode(LPoint pt, Rectangle2D cell) throws Exception;
		abstract Node deleteNode(Point2D pt);
		abstract int size();
		abstract boolean inNode();
		abstract LPoint leftMostPoint();
		abstract ArrayList<String> listNodes();
		abstract ArrayList<LPoint> getPointList();
		public String toString() {
			return "";
		}
		abstract void addCenter(LPoint center);
		abstract ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint);
		abstract Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception;
	}
	
	private class ByXThenY implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(0)!=pt2.get(0)) {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			} else {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			}
		}
	}
	private class ByYThenX implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(1)!=pt2.get(1)) {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			} else {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			}
		}
	}
	
	public double min4(double a, double b, double c, double d) {
		return (a<b):((a<c):)?()
	}
	
	private class InternalNode extends Node {
		int cutDim;
		double cutVal;
		Node left, right;
		int size; //n counter from slides (Lect12)
		int insertionCounter; //m counter from slides (Lect12)
		Rectangle2D cell;
		double rMin;
		
		void addCenter(LPoint center) {
			if (cell.contains(center.getPoint2D())) {
				double tempMin;
			}
				
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			
			//create cells based on value of cutDim
			Rectangle2D lcell = new Rectangle2D(cell.low,
					(cutDim==0?new Point2D(cutVal,cell.high.get(cutDim==0?1:0))
							:new Point2D(cell.high.get(cutDim==0?1:0),cutVal)));
			Rectangle2D rcell = new Rectangle2D((cutDim==0? 
					new Point2D(cutVal,cell.low.get(cutDim==0?1:0))
							:new Point2D(cell.low.get(cutDim==0?1:0),cutVal)),
									cell.high);
			
			
			if (bestPoint.size() == 0) {
				// if size == 0 we must call nearestNeighbor on one subtree 
				// and then potentially on the other
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					bestPoint = left.nearestNeighborNode(center, bestPoint);//rec1 //rec4
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
					}
				} else {
					bestPoint = right.nearestNeighborNode(center, bestPoint);//rec2 //rec3
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						//System.out.println("arrived 2 at cutDim: " + cutDim + " and cutVal: " + cutVal);
						bestPoint = left.nearestNeighborNode(center, bestPoint);
					}
				}
			} else {
				// if size != 0 we might need to call nearestNeighbor on one
				// subtree and if so maybe on the other as well
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						bestPoint = left.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
							bestPoint = right.nearestNeighborNode(center, bestPoint);
						}
					}
				} else {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
							bestPoint = left.nearestNeighborNode(center, bestPoint);
						}
					}
				}
			}
			return bestPoint;
			
			
			
		}
		
		Node deleteNode(Point2D pt) {
			if (pt.get(cutDim)<cutVal) {
				Node node = left.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			} else {
				Node node = right.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			}
		}
		
		public String toString() {
			return "{"+left.toString() + "\n[Cut Dim: "+cutDim+"  Cut Val: "+cutVal+
					"   Size: "+size+"   Insertions: "+insertionCounter+"]\n"+
					right.toString()+"}";
		}
		
		boolean inNode() { return true; }
		
		LPoint leftMostPoint() { return left.leftMostPoint(); }
		
		public InternalNode(int cutDim, double cutVal, Rectangle2D cell) {
			this.cutDim = cutDim;
			this.cutVal = cutVal;
			size = 0;
			insertionCounter = 0;
			this.cell = cell;
			this.left = new ExternalNode(null);
			this.right = new ExternalNode(null);
		}
		
		int size() { return size; }
		
		LPoint findNode(Point2D q) {
			if (q.get(cutDim)<cutVal) {
				return left.findNode(q);
			} else {
				return right.findNode(q);
			}
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) {
			//create externalNode if size == 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			}
			if (points.size()==1) {
				return new ExternalNode(points.get(0));
			}
			
			//otherwise have to split into two new cells
			int myDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			Collections.sort(points, (myDim==0?new ByXThenY():new ByYThenX()));
			if (points.get(0).get(myDim)==points.get(points.size()-1).get(myDim)) {
				//degenerate nodes in a line
				myDim = myDim==0?1:0; //switch cutting dimension
			}
			
			double myVal = (cell.getHigh().get(myDim)+cell.getLow().get(myDim))/2;
			if (myVal<points.get(0).get(myDim)) {
				myVal = points.get(0).get(myDim); //slide midpoint
			} else if (myVal>points.get(points.size()-1).get(myDim)) {
				myVal = points.get(points.size()-1).get(myDim); //slide midpoint
			}
			
			//seperate points into new lists
			ArrayList<LPoint> leftPoints = new ArrayList<LPoint>();
			ArrayList<LPoint> rightPoints = new ArrayList<LPoint>();
			for (int i = 0; i < points.size(); i++) {
				if (points.get(i).get(myDim)<myVal) {
					leftPoints.add(points.get(i));
				} else {
					rightPoints.add(points.get(i));
				}
			}
			
			
			Rectangle2D lcell = new Rectangle2D(cell.low,
						(myDim==0?new Point2D(myVal,cell.high.get(myDim==0?1:0))
								:new Point2D(cell.high.get(myDim==0?1:0),myVal)));
			Rectangle2D rcell = new Rectangle2D((myDim==0? 
					new Point2D(myVal,cell.low.get(myDim==0?1:0))
					:new Point2D(cell.low.get(myDim==0?1:0),myVal)),
					cell.high);
			
		
			
			InternalNode returnNode = new InternalNode(myDim, myVal, cell);
			returnNode.left = bulkCreate(leftPoints,lcell);
			returnNode.right = bulkCreate(rightPoints,rcell);
			returnNode.size = points.size();
			
			return returnNode;
			
		}
		
		
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			temp.addAll(left.getPointList());
			temp.addAll(right.getPointList());
			return temp;
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (pt.get(cutDim)<cutVal) {
				left = left.insertNode(pt, cutDim==0?(new Rectangle2D(this.cell.low,
						new Point2D(cutVal,this.cell.high.getY()))):
							(new Rectangle2D(this.cell.low,
									new Point2D(this.cell.high.getX(),cutVal))));
				
			} else {
				right = right.insertNode(pt, cutDim==0?(new Rectangle2D(
						new Point2D(cutVal,this.cell.low.getY()),this.cell.high)):
							(new Rectangle2D(new Point2D(this.cell.low.getX(),cutVal)
									,this.cell.high)));
				
			}
			size++;
			insertionCounter++;
			if (insertionCounter > (size + REBUILDOFFSET)/2) {
				return bulkCreate(getPointList(),cell);
			} else {
				return this;
			}
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			if (cutDim==0)
				retVal.add("(x=" + cutVal + ") " + size + ":" + insertionCounter);
			else
				retVal.add("(y=" + cutVal + ") " + size + ":" + insertionCounter);
			retVal.addAll(right.listNodes());
			retVal.addAll(left.listNodes());
			return retVal;
		}
	}
	
	private class ExternalNode extends Node {
		LPoint point;
		
		void addCenter(LPoint center) {
			
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (point == null) {
				return bestPoint;
			}
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			if(bestPoint.size()==0 ) {
				bestPoint.add(point);
			} else if (bestPoint.get(0).getPoint2D().distance(center)>=point.getPoint2D().distance(center)) {
				if(bestPoint.get(0).getPoint2D().distance(center)==point.getPoint2D().distance(center)) {
					if (bestPoint.get(0).getX()>point.getX()) {
						bestPoint.add(0, point);
					} else if (bestPoint.get(0).getX()==point.getX() &&
							bestPoint.get(0).getY()>point.getY()) {
						//new best point because of lower lexicographic score
						bestPoint.add(0, point);
					} else {
						bestPoint.add(point);
					}
				} else {
					//must be a best point because dist is less than old best
					bestPoint.add(0, point);
				}
			} else {
				bestPoint.add(point);
			}
			return bestPoint;
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception {
			//will only ever be called on a tree of size 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			} 
			return new ExternalNode(points.get(0));
		}
		
		Node deleteNode(Point2D pt) {
			if (point == null) {
				return null;
			} else if (point.getPoint2D().equals(pt)) {
				point = null;
				return this;
			} else {
				return null;
			}
		}
		
		int size() { return point==null?0:1; }
		
		public String toString() {
			if (point != null)
				return "("+point.getX()+", "+point.getY()+") ";
			else
				return "null point";
		}
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			if (point!=null) {
				temp.add(point);
			}
			return temp;
		}
		
		ExternalNode(LPoint point) {
			this.point = point;
		}
		
		boolean inNode() { return false; }
		
		LPoint leftMostPoint() { return point; }
		
		LPoint findNode(Point2D q) {
			if (point == null) {
				return null;
			}
			if (point.getPoint2D().equals(q)) {
				return point;
			} else {
				return null;
			}
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (point == null) {
				point = pt;
				return this;
			}
			if (point.getPoint2D().equals(pt.getPoint2D())) {
				throw new Exception("Insertion of duplicate point");
			}
			//find cutDim
			int cutDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			if (pt.get(cutDim)==point.get(cutDim)) {
				cutDim = cutDim==0?1:0; //if x is cutDim and x's are equal make
				//cutDim Y and vice versa
			}
			
			//find our cutVal
			double cutVal = (cell.high.get(cutDim)+cell.low.get(cutDim))/2;
			double pointVal = point.get(cutDim);
			double ptVal = pt.get(cutDim);
			if (cutVal>pointVal && cutVal>ptVal) {
				cutVal = pointVal>ptVal?pointVal:ptVal;
			} else if (cutVal<pointVal && cutVal<ptVal) {
				cutVal = pointVal<ptVal?pointVal:ptVal;
			}
			
			//create our new internal node
			InternalNode node = new InternalNode(cutDim, cutVal, cell);
			//add our external nodes
			node.insertNode(pt, cell);
			node.insertNode(point, cell);
			node.insertionCounter = 0;
			return node;
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			retVal.add("["+(point==null?"null":point.toString()) + "]");
			return retVal;
		}

		
	}
	
	public SMkdTreeMe(int rebuildOffset, Rectangle2D rootCell) { 
		REBUILDOFFSET = rebuildOffset;
		this.rootCell = rootCell;
		root = new ExternalNode(null);
		deleteCount = 0;
	}
	public void clear() { root = new ExternalNode(null); }
	public int size() { return root==null?0:root.size(); }
	public int deleteCount() { return deleteCount; }
	public LPoint find(Point2D q) { return root.findNode(q); }
	public void insert(LPoint pt) throws Exception { 
		if (!rootCell.contains(pt.getPoint2D()))
			throw new Exception("Attempt to insert a point outside bounding box");
		root = root.insertNode(pt, rootCell);
	}
	public void delete(Point2D pt) throws Exception { 
		Node node = root.deleteNode(pt);
		if (node == null) {
			throw new Exception("Deletion of nonexistent point");
		} else {
			deleteCount++;
			if (deleteCount>size()) {
				root = root.bulkCreate(root.getPointList(),rootCell);
				deleteCount = 0;
			}
		}
	}
	public ArrayList<String> list() { return root.listNodes(); }
	public LPoint nearestNeighbor(Point2D center) { 
		if (size()==0) 
			return null;
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		return points.get(0);
	}
	public ArrayList<LPoint> nearestNeighborVisit(Point2D center) { 
		if (size()==0) 
			return new ArrayList<LPoint>();
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		Collections.sort(points, new ByXThenY());
		return points;
	}

	public String toString() {
		return root.toString();
	}
	
	
	// ----------------------------------------------------------------
	// Possible new additions for Programming Assignment 3
	// You may modify/add/remove these as you see fit, since they will 
	// just be used internally by your code.
	// ----------------------------------------------------------------
	void addCenter(LPoint center) { 
		root.addCenter(center);
	}
	// ArrayList<String> listWithCenters() { /* ... */ return null; }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-17 14:29:27.333
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-17 14:29:27.336
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-17 14:29:27.386
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

public class SMkdTreeMe<LPoint extends LabeledPoint2D> {
		
	private final int REBUILDOFFSET;
	private Rectangle2D rootCell;
	private Node root;
	private int deleteCount;
	
	private abstract class Node {
		private LinkedList<LPoint> contenders;
		abstract LPoint findNode(Point2D q);
		abstract Node insertNode(LPoint pt, Rectangle2D cell) throws Exception;
		abstract Node deleteNode(Point2D pt);
		abstract int size();
		abstract boolean inNode();
		abstract LPoint leftMostPoint();
		abstract ArrayList<String> listNodes();
		abstract ArrayList<LPoint> getPointList();
		public String toString() {
			return "";
		}
		abstract void addCenter(LPoint center);
		abstract ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint);
		abstract Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception;
	}
	
	private class ByXThenY implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(0)!=pt2.get(0)) {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			} else {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			}
		}
	}
	private class ByYThenX implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(1)!=pt2.get(1)) {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			} else {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			}
		}
	}
	
	public double min4(double a, double b, double c, double d) {
		return (a<b):((a<c):)?()
	}
	
	private class InternalNode extends Node {
		int cutDim;
		double cutVal;
		Node left, right;
		int size; //n counter from slides (Lect12)
		int insertionCounter; //m counter from slides (Lect12)
		Rectangle2D cell;
		double rMin;
		
		void addCenter(LPoint center) {
			if (cell.contains(center.getPoint2D())) {
				double tempMin;
			}
				
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			
			//create cells based on value of cutDim
			Rectangle2D lcell = new Rectangle2D(cell.low,
					(cutDim==0?new Point2D(cutVal,cell.high.get(cutDim==0?1:0))
							:new Point2D(cell.high.get(cutDim==0?1:0),cutVal)));
			Rectangle2D rcell = new Rectangle2D((cutDim==0? 
					new Point2D(cutVal,cell.low.get(cutDim==0?1:0))
							:new Point2D(cell.low.get(cutDim==0?1:0),cutVal)),
									cell.high);
			
			
			if (bestPoint.size() == 0) {
				// if size == 0 we must call nearestNeighbor on one subtree 
				// and then potentially on the other
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					bestPoint = left.nearestNeighborNode(center, bestPoint);//rec1 //rec4
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
					}
				} else {
					bestPoint = right.nearestNeighborNode(center, bestPoint);//rec2 //rec3
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						//System.out.println("arrived 2 at cutDim: " + cutDim + " and cutVal: " + cutVal);
						bestPoint = left.nearestNeighborNode(center, bestPoint);
					}
				}
			} else {
				// if size != 0 we might need to call nearestNeighbor on one
				// subtree and if so maybe on the other as well
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						bestPoint = left.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
							bestPoint = right.nearestNeighborNode(center, bestPoint);
						}
					}
				} else {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
							bestPoint = left.nearestNeighborNode(center, bestPoint);
						}
					}
				}
			}
			return bestPoint;
			
			
			
		}
		
		Node deleteNode(Point2D pt) {
			if (pt.get(cutDim)<cutVal) {
				Node node = left.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			} else {
				Node node = right.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			}
		}
		
		public String toString() {
			return "{"+left.toString() + "\n[Cut Dim: "+cutDim+"  Cut Val: "+cutVal+
					"   Size: "+size+"   Insertions: "+insertionCounter+"]\n"+
					right.toString()+"}";
		}
		
		boolean inNode() { return true; }
		
		LPoint leftMostPoint() { return left.leftMostPoint(); }
		
		public InternalNode(int cutDim, double cutVal, Rectangle2D cell) {
			this.cutDim = cutDim;
			this.cutVal = cutVal;
			size = 0;
			insertionCounter = 0;
			this.cell = cell;
			this.left = new ExternalNode(null);
			this.right = new ExternalNode(null);
		}
		
		int size() { return size; }
		
		LPoint findNode(Point2D q) {
			if (q.get(cutDim)<cutVal) {
				return left.findNode(q);
			} else {
				return right.findNode(q);
			}
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) {
			//create externalNode if size == 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			}
			if (points.size()==1) {
				return new ExternalNode(points.get(0));
			}
			
			//otherwise have to split into two new cells
			int myDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			Collections.sort(points, (myDim==0?new ByXThenY():new ByYThenX()));
			if (points.get(0).get(myDim)==points.get(points.size()-1).get(myDim)) {
				//degenerate nodes in a line
				myDim = myDim==0?1:0; //switch cutting dimension
			}
			
			double myVal = (cell.getHigh().get(myDim)+cell.getLow().get(myDim))/2;
			if (myVal<points.get(0).get(myDim)) {
				myVal = points.get(0).get(myDim); //slide midpoint
			} else if (myVal>points.get(points.size()-1).get(myDim)) {
				myVal = points.get(points.size()-1).get(myDim); //slide midpoint
			}
			
			//seperate points into new lists
			ArrayList<LPoint> leftPoints = new ArrayList<LPoint>();
			ArrayList<LPoint> rightPoints = new ArrayList<LPoint>();
			for (int i = 0; i < points.size(); i++) {
				if (points.get(i).get(myDim)<myVal) {
					leftPoints.add(points.get(i));
				} else {
					rightPoints.add(points.get(i));
				}
			}
			
			
			Rectangle2D lcell = new Rectangle2D(cell.low,
						(myDim==0?new Point2D(myVal,cell.high.get(myDim==0?1:0))
								:new Point2D(cell.high.get(myDim==0?1:0),myVal)));
			Rectangle2D rcell = new Rectangle2D((myDim==0? 
					new Point2D(myVal,cell.low.get(myDim==0?1:0))
					:new Point2D(cell.low.get(myDim==0?1:0),myVal)),
					cell.high);
			
		
			
			InternalNode returnNode = new InternalNode(myDim, myVal, cell);
			returnNode.left = bulkCreate(leftPoints,lcell);
			returnNode.right = bulkCreate(rightPoints,rcell);
			returnNode.size = points.size();
			
			return returnNode;
			
		}
		
		
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			temp.addAll(left.getPointList());
			temp.addAll(right.getPointList());
			return temp;
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (pt.get(cutDim)<cutVal) {
				left = left.insertNode(pt, cutDim==0?(new Rectangle2D(this.cell.low,
						new Point2D(cutVal,this.cell.high.getY()))):
							(new Rectangle2D(this.cell.low,
									new Point2D(this.cell.high.getX(),cutVal))));
				
			} else {
				right = right.insertNode(pt, cutDim==0?(new Rectangle2D(
						new Point2D(cutVal,this.cell.low.getY()),this.cell.high)):
							(new Rectangle2D(new Point2D(this.cell.low.getX(),cutVal)
									,this.cell.high)));
				
			}
			size++;
			insertionCounter++;
			if (insertionCounter > (size + REBUILDOFFSET)/2) {
				return bulkCreate(getPointList(),cell);
			} else {
				return this;
			}
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			if (cutDim==0)
				retVal.add("(x=" + cutVal + ") " + size + ":" + insertionCounter);
			else
				retVal.add("(y=" + cutVal + ") " + size + ":" + insertionCounter);
			retVal.addAll(right.listNodes());
			retVal.addAll(left.listNodes());
			return retVal;
		}
	}
	
	private class ExternalNode extends Node {
		LPoint point;
		
		void addCenter(LPoint center) {
			
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (point == null) {
				return bestPoint;
			}
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			if(bestPoint.size()==0 ) {
				bestPoint.add(point);
			} else if (bestPoint.get(0).getPoint2D().distance(center)>=point.getPoint2D().distance(center)) {
				if(bestPoint.get(0).getPoint2D().distance(center)==point.getPoint2D().distance(center)) {
					if (bestPoint.get(0).getX()>point.getX()) {
						bestPoint.add(0, point);
					} else if (bestPoint.get(0).getX()==point.getX() &&
							bestPoint.get(0).getY()>point.getY()) {
						//new best point because of lower lexicographic score
						bestPoint.add(0, point);
					} else {
						bestPoint.add(point);
					}
				} else {
					//must be a best point because dist is less than old best
					bestPoint.add(0, point);
				}
			} else {
				bestPoint.add(point);
			}
			return bestPoint;
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception {
			//will only ever be called on a tree of size 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			} 
			return new ExternalNode(points.get(0));
		}
		
		Node deleteNode(Point2D pt) {
			if (point == null) {
				return null;
			} else if (point.getPoint2D().equals(pt)) {
				point = null;
				return this;
			} else {
				return null;
			}
		}
		
		int size() { return point==null?0:1; }
		
		public String toString() {
			if (point != null)
				return "("+point.getX()+", "+point.getY()+") ";
			else
				return "null point";
		}
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			if (point!=null) {
				temp.add(point);
			}
			return temp;
		}
		
		ExternalNode(LPoint point) {
			this.point = point;
		}
		
		boolean inNode() { return false; }
		
		LPoint leftMostPoint() { return point; }
		
		LPoint findNode(Point2D q) {
			if (point == null) {
				return null;
			}
			if (point.getPoint2D().equals(q)) {
				return point;
			} else {
				return null;
			}
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (point == null) {
				point = pt;
				return this;
			}
			if (point.getPoint2D().equals(pt.getPoint2D())) {
				throw new Exception("Insertion of duplicate point");
			}
			//find cutDim
			int cutDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			if (pt.get(cutDim)==point.get(cutDim)) {
				cutDim = cutDim==0?1:0; //if x is cutDim and x's are equal make
				//cutDim Y and vice versa
			}
			
			//find our cutVal
			double cutVal = (cell.high.get(cutDim)+cell.low.get(cutDim))/2;
			double pointVal = point.get(cutDim);
			double ptVal = pt.get(cutDim);
			if (cutVal>pointVal && cutVal>ptVal) {
				cutVal = pointVal>ptVal?pointVal:ptVal;
			} else if (cutVal<pointVal && cutVal<ptVal) {
				cutVal = pointVal<ptVal?pointVal:ptVal;
			}
			
			//create our new internal node
			InternalNode node = new InternalNode(cutDim, cutVal, cell);
			//add our external nodes
			node.insertNode(pt, cell);
			node.insertNode(point, cell);
			node.insertionCounter = 0;
			return node;
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			retVal.add("["+(point==null?"null":point.toString()) + "]");
			return retVal;
		}

		
	}
	
	public SMkdTreeMe(int rebuildOffset, Rectangle2D rootCell) { 
		REBUILDOFFSET = rebuildOffset;
		this.rootCell = rootCell;
		root = new ExternalNode(null);
		deleteCount = 0;
	}
	public void clear() { root = new ExternalNode(null); }
	public int size() { return root==null?0:root.size(); }
	public int deleteCount() { return deleteCount; }
	public LPoint find(Point2D q) { return root.findNode(q); }
	public void insert(LPoint pt) throws Exception { 
		if (!rootCell.contains(pt.getPoint2D()))
			throw new Exception("Attempt to insert a point outside bounding box");
		root = root.insertNode(pt, rootCell);
	}
	public void delete(Point2D pt) throws Exception { 
		Node node = root.deleteNode(pt);
		if (node == null) {
			throw new Exception("Deletion of nonexistent point");
		} else {
			deleteCount++;
			if (deleteCount>size()) {
				root = root.bulkCreate(root.getPointList(),rootCell);
				deleteCount = 0;
			}
		}
	}
	public ArrayList<String> list() { return root.listNodes(); }
	public LPoint nearestNeighbor(Point2D center) { 
		if (size()==0) 
			return null;
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		return points.get(0);
	}
	public ArrayList<LPoint> nearestNeighborVisit(Point2D center) { 
		if (size()==0) 
			return new ArrayList<LPoint>();
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		Collections.sort(points, new ByXThenY());
		return points;
	}

	public String toString() {
		return root.toString();
	}
	
	
	// ----------------------------------------------------------------
	// Possible new additions for Programming Assignment 3
	// You may modify/add/remove these as you see fit, since they will 
	// just be used internally by your code.
	// ----------------------------------------------------------------
	void addCenter(LPoint center) { 
		root.addCenter(center);
	}
	// ArrayList<String> listWithCenters() { /* ... */ return null; }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-17 14:29:27.389
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-17 14:29:27.392
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-17 14:29:28.425
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

public class SMkdTreeMe<LPoint extends LabeledPoint2D> {
		
	private final int REBUILDOFFSET;
	private Rectangle2D rootCell;
	private Node root;
	private int deleteCount;
	
	private abstract class Node {
		private LinkedList<LPoint> contenders;
		abstract LPoint findNode(Point2D q);
		abstract Node insertNode(LPoint pt, Rectangle2D cell) throws Exception;
		abstract Node deleteNode(Point2D pt);
		abstract int size();
		abstract boolean inNode();
		abstract LPoint leftMostPoint();
		abstract ArrayList<String> listNodes();
		abstract ArrayList<LPoint> getPointList();
		public String toString() {
			return "";
		}
		abstract void addCenter(LPoint center);
		abstract ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint);
		abstract Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception;
	}
	
	private class ByXThenY implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(0)!=pt2.get(0)) {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			} else {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			}
		}
	}
	private class ByYThenX implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(1)!=pt2.get(1)) {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			} else {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			}
		}
	}
	
	public double min4(double a, double b, double c, double d) {
		return (a<b):((a<c):())?()
	}
	
	private class InternalNode extends Node {
		int cutDim;
		double cutVal;
		Node left, right;
		int size; //n counter from slides (Lect12)
		int insertionCounter; //m counter from slides (Lect12)
		Rectangle2D cell;
		double rMin;
		
		void addCenter(LPoint center) {
			if (cell.contains(center.getPoint2D())) {
				double tempMin;
			}
				
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			
			//create cells based on value of cutDim
			Rectangle2D lcell = new Rectangle2D(cell.low,
					(cutDim==0?new Point2D(cutVal,cell.high.get(cutDim==0?1:0))
							:new Point2D(cell.high.get(cutDim==0?1:0),cutVal)));
			Rectangle2D rcell = new Rectangle2D((cutDim==0? 
					new Point2D(cutVal,cell.low.get(cutDim==0?1:0))
							:new Point2D(cell.low.get(cutDim==0?1:0),cutVal)),
									cell.high);
			
			
			if (bestPoint.size() == 0) {
				// if size == 0 we must call nearestNeighbor on one subtree 
				// and then potentially on the other
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					bestPoint = left.nearestNeighborNode(center, bestPoint);//rec1 //rec4
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
					}
				} else {
					bestPoint = right.nearestNeighborNode(center, bestPoint);//rec2 //rec3
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						//System.out.println("arrived 2 at cutDim: " + cutDim + " and cutVal: " + cutVal);
						bestPoint = left.nearestNeighborNode(center, bestPoint);
					}
				}
			} else {
				// if size != 0 we might need to call nearestNeighbor on one
				// subtree and if so maybe on the other as well
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						bestPoint = left.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
							bestPoint = right.nearestNeighborNode(center, bestPoint);
						}
					}
				} else {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
							bestPoint = left.nearestNeighborNode(center, bestPoint);
						}
					}
				}
			}
			return bestPoint;
			
			
			
		}
		
		Node deleteNode(Point2D pt) {
			if (pt.get(cutDim)<cutVal) {
				Node node = left.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			} else {
				Node node = right.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			}
		}
		
		public String toString() {
			return "{"+left.toString() + "\n[Cut Dim: "+cutDim+"  Cut Val: "+cutVal+
					"   Size: "+size+"   Insertions: "+insertionCounter+"]\n"+
					right.toString()+"}";
		}
		
		boolean inNode() { return true; }
		
		LPoint leftMostPoint() { return left.leftMostPoint(); }
		
		public InternalNode(int cutDim, double cutVal, Rectangle2D cell) {
			this.cutDim = cutDim;
			this.cutVal = cutVal;
			size = 0;
			insertionCounter = 0;
			this.cell = cell;
			this.left = new ExternalNode(null);
			this.right = new ExternalNode(null);
		}
		
		int size() { return size; }
		
		LPoint findNode(Point2D q) {
			if (q.get(cutDim)<cutVal) {
				return left.findNode(q);
			} else {
				return right.findNode(q);
			}
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) {
			//create externalNode if size == 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			}
			if (points.size()==1) {
				return new ExternalNode(points.get(0));
			}
			
			//otherwise have to split into two new cells
			int myDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			Collections.sort(points, (myDim==0?new ByXThenY():new ByYThenX()));
			if (points.get(0).get(myDim)==points.get(points.size()-1).get(myDim)) {
				//degenerate nodes in a line
				myDim = myDim==0?1:0; //switch cutting dimension
			}
			
			double myVal = (cell.getHigh().get(myDim)+cell.getLow().get(myDim))/2;
			if (myVal<points.get(0).get(myDim)) {
				myVal = points.get(0).get(myDim); //slide midpoint
			} else if (myVal>points.get(points.size()-1).get(myDim)) {
				myVal = points.get(points.size()-1).get(myDim); //slide midpoint
			}
			
			//seperate points into new lists
			ArrayList<LPoint> leftPoints = new ArrayList<LPoint>();
			ArrayList<LPoint> rightPoints = new ArrayList<LPoint>();
			for (int i = 0; i < points.size(); i++) {
				if (points.get(i).get(myDim)<myVal) {
					leftPoints.add(points.get(i));
				} else {
					rightPoints.add(points.get(i));
				}
			}
			
			
			Rectangle2D lcell = new Rectangle2D(cell.low,
						(myDim==0?new Point2D(myVal,cell.high.get(myDim==0?1:0))
								:new Point2D(cell.high.get(myDim==0?1:0),myVal)));
			Rectangle2D rcell = new Rectangle2D((myDim==0? 
					new Point2D(myVal,cell.low.get(myDim==0?1:0))
					:new Point2D(cell.low.get(myDim==0?1:0),myVal)),
					cell.high);
			
		
			
			InternalNode returnNode = new InternalNode(myDim, myVal, cell);
			returnNode.left = bulkCreate(leftPoints,lcell);
			returnNode.right = bulkCreate(rightPoints,rcell);
			returnNode.size = points.size();
			
			return returnNode;
			
		}
		
		
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			temp.addAll(left.getPointList());
			temp.addAll(right.getPointList());
			return temp;
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (pt.get(cutDim)<cutVal) {
				left = left.insertNode(pt, cutDim==0?(new Rectangle2D(this.cell.low,
						new Point2D(cutVal,this.cell.high.getY()))):
							(new Rectangle2D(this.cell.low,
									new Point2D(this.cell.high.getX(),cutVal))));
				
			} else {
				right = right.insertNode(pt, cutDim==0?(new Rectangle2D(
						new Point2D(cutVal,this.cell.low.getY()),this.cell.high)):
							(new Rectangle2D(new Point2D(this.cell.low.getX(),cutVal)
									,this.cell.high)));
				
			}
			size++;
			insertionCounter++;
			if (insertionCounter > (size + REBUILDOFFSET)/2) {
				return bulkCreate(getPointList(),cell);
			} else {
				return this;
			}
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			if (cutDim==0)
				retVal.add("(x=" + cutVal + ") " + size + ":" + insertionCounter);
			else
				retVal.add("(y=" + cutVal + ") " + size + ":" + insertionCounter);
			retVal.addAll(right.listNodes());
			retVal.addAll(left.listNodes());
			return retVal;
		}
	}
	
	private class ExternalNode extends Node {
		LPoint point;
		
		void addCenter(LPoint center) {
			
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (point == null) {
				return bestPoint;
			}
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			if(bestPoint.size()==0 ) {
				bestPoint.add(point);
			} else if (bestPoint.get(0).getPoint2D().distance(center)>=point.getPoint2D().distance(center)) {
				if(bestPoint.get(0).getPoint2D().distance(center)==point.getPoint2D().distance(center)) {
					if (bestPoint.get(0).getX()>point.getX()) {
						bestPoint.add(0, point);
					} else if (bestPoint.get(0).getX()==point.getX() &&
							bestPoint.get(0).getY()>point.getY()) {
						//new best point because of lower lexicographic score
						bestPoint.add(0, point);
					} else {
						bestPoint.add(point);
					}
				} else {
					//must be a best point because dist is less than old best
					bestPoint.add(0, point);
				}
			} else {
				bestPoint.add(point);
			}
			return bestPoint;
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception {
			//will only ever be called on a tree of size 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			} 
			return new ExternalNode(points.get(0));
		}
		
		Node deleteNode(Point2D pt) {
			if (point == null) {
				return null;
			} else if (point.getPoint2D().equals(pt)) {
				point = null;
				return this;
			} else {
				return null;
			}
		}
		
		int size() { return point==null?0:1; }
		
		public String toString() {
			if (point != null)
				return "("+point.getX()+", "+point.getY()+") ";
			else
				return "null point";
		}
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			if (point!=null) {
				temp.add(point);
			}
			return temp;
		}
		
		ExternalNode(LPoint point) {
			this.point = point;
		}
		
		boolean inNode() { return false; }
		
		LPoint leftMostPoint() { return point; }
		
		LPoint findNode(Point2D q) {
			if (point == null) {
				return null;
			}
			if (point.getPoint2D().equals(q)) {
				return point;
			} else {
				return null;
			}
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (point == null) {
				point = pt;
				return this;
			}
			if (point.getPoint2D().equals(pt.getPoint2D())) {
				throw new Exception("Insertion of duplicate point");
			}
			//find cutDim
			int cutDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			if (pt.get(cutDim)==point.get(cutDim)) {
				cutDim = cutDim==0?1:0; //if x is cutDim and x's are equal make
				//cutDim Y and vice versa
			}
			
			//find our cutVal
			double cutVal = (cell.high.get(cutDim)+cell.low.get(cutDim))/2;
			double pointVal = point.get(cutDim);
			double ptVal = pt.get(cutDim);
			if (cutVal>pointVal && cutVal>ptVal) {
				cutVal = pointVal>ptVal?pointVal:ptVal;
			} else if (cutVal<pointVal && cutVal<ptVal) {
				cutVal = pointVal<ptVal?pointVal:ptVal;
			}
			
			//create our new internal node
			InternalNode node = new InternalNode(cutDim, cutVal, cell);
			//add our external nodes
			node.insertNode(pt, cell);
			node.insertNode(point, cell);
			node.insertionCounter = 0;
			return node;
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			retVal.add("["+(point==null?"null":point.toString()) + "]");
			return retVal;
		}

		
	}
	
	public SMkdTreeMe(int rebuildOffset, Rectangle2D rootCell) { 
		REBUILDOFFSET = rebuildOffset;
		this.rootCell = rootCell;
		root = new ExternalNode(null);
		deleteCount = 0;
	}
	public void clear() { root = new ExternalNode(null); }
	public int size() { return root==null?0:root.size(); }
	public int deleteCount() { return deleteCount; }
	public LPoint find(Point2D q) { return root.findNode(q); }
	public void insert(LPoint pt) throws Exception { 
		if (!rootCell.contains(pt.getPoint2D()))
			throw new Exception("Attempt to insert a point outside bounding box");
		root = root.insertNode(pt, rootCell);
	}
	public void delete(Point2D pt) throws Exception { 
		Node node = root.deleteNode(pt);
		if (node == null) {
			throw new Exception("Deletion of nonexistent point");
		} else {
			deleteCount++;
			if (deleteCount>size()) {
				root = root.bulkCreate(root.getPointList(),rootCell);
				deleteCount = 0;
			}
		}
	}
	public ArrayList<String> list() { return root.listNodes(); }
	public LPoint nearestNeighbor(Point2D center) { 
		if (size()==0) 
			return null;
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		return points.get(0);
	}
	public ArrayList<LPoint> nearestNeighborVisit(Point2D center) { 
		if (size()==0) 
			return new ArrayList<LPoint>();
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		Collections.sort(points, new ByXThenY());
		return points;
	}

	public String toString() {
		return root.toString();
	}
	
	
	// ----------------------------------------------------------------
	// Possible new additions for Programming Assignment 3
	// You may modify/add/remove these as you see fit, since they will 
	// just be used internally by your code.
	// ----------------------------------------------------------------
	void addCenter(LPoint center) { 
		root.addCenter(center);
	}
	// ArrayList<String> listWithCenters() { /* ... */ return null; }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-05-17 14:29:28.432
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-05-17 14:29:28.435
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-17 14:29:28.469
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

public class SMkdTreeMe<LPoint extends LabeledPoint2D> {
		
	private final int REBUILDOFFSET;
	private Rectangle2D rootCell;
	private Node root;
	private int deleteCount;
	
	private abstract class Node {
		private LinkedList<LPoint> contenders;
		abstract LPoint findNode(Point2D q);
		abstract Node insertNode(LPoint pt, Rectangle2D cell) throws Exception;
		abstract Node deleteNode(Point2D pt);
		abstract int size();
		abstract boolean inNode();
		abstract LPoint leftMostPoint();
		abstract ArrayList<String> listNodes();
		abstract ArrayList<LPoint> getPointList();
		public String toString() {
			return "";
		}
		abstract void addCenter(LPoint center);
		abstract ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint);
		abstract Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception;
	}
	
	private class ByXThenY implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(0)!=pt2.get(0)) {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			} else {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			}
		}
	}
	private class ByYThenX implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(1)!=pt2.get(1)) {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			} else {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			}
		}
	}
	
	public double min4(double a, double b, double c, double d) {
		return (a<b):((a<c):())?()
	}
	
	private class InternalNode extends Node {
		int cutDim;
		double cutVal;
		Node left, right;
		int size; //n counter from slides (Lect12)
		int insertionCounter; //m counter from slides (Lect12)
		Rectangle2D cell;
		double rMin;
		
		void addCenter(LPoint center) {
			if (cell.contains(center.getPoint2D())) {
				double tempMin;
			}
				
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			
			//create cells based on value of cutDim
			Rectangle2D lcell = new Rectangle2D(cell.low,
					(cutDim==0?new Point2D(cutVal,cell.high.get(cutDim==0?1:0))
							:new Point2D(cell.high.get(cutDim==0?1:0),cutVal)));
			Rectangle2D rcell = new Rectangle2D((cutDim==0? 
					new Point2D(cutVal,cell.low.get(cutDim==0?1:0))
							:new Point2D(cell.low.get(cutDim==0?1:0),cutVal)),
									cell.high);
			
			
			if (bestPoint.size() == 0) {
				// if size == 0 we must call nearestNeighbor on one subtree 
				// and then potentially on the other
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					bestPoint = left.nearestNeighborNode(center, bestPoint);//rec1 //rec4
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
					}
				} else {
					bestPoint = right.nearestNeighborNode(center, bestPoint);//rec2 //rec3
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						//System.out.println("arrived 2 at cutDim: " + cutDim + " and cutVal: " + cutVal);
						bestPoint = left.nearestNeighborNode(center, bestPoint);
					}
				}
			} else {
				// if size != 0 we might need to call nearestNeighbor on one
				// subtree and if so maybe on the other as well
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						bestPoint = left.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
							bestPoint = right.nearestNeighborNode(center, bestPoint);
						}
					}
				} else {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
							bestPoint = left.nearestNeighborNode(center, bestPoint);
						}
					}
				}
			}
			return bestPoint;
			
			
			
		}
		
		Node deleteNode(Point2D pt) {
			if (pt.get(cutDim)<cutVal) {
				Node node = left.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			} else {
				Node node = right.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			}
		}
		
		public String toString() {
			return "{"+left.toString() + "\n[Cut Dim: "+cutDim+"  Cut Val: "+cutVal+
					"   Size: "+size+"   Insertions: "+insertionCounter+"]\n"+
					right.toString()+"}";
		}
		
		boolean inNode() { return true; }
		
		LPoint leftMostPoint() { return left.leftMostPoint(); }
		
		public InternalNode(int cutDim, double cutVal, Rectangle2D cell) {
			this.cutDim = cutDim;
			this.cutVal = cutVal;
			size = 0;
			insertionCounter = 0;
			this.cell = cell;
			this.left = new ExternalNode(null);
			this.right = new ExternalNode(null);
		}
		
		int size() { return size; }
		
		LPoint findNode(Point2D q) {
			if (q.get(cutDim)<cutVal) {
				return left.findNode(q);
			} else {
				return right.findNode(q);
			}
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) {
			//create externalNode if size == 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			}
			if (points.size()==1) {
				return new ExternalNode(points.get(0));
			}
			
			//otherwise have to split into two new cells
			int myDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			Collections.sort(points, (myDim==0?new ByXThenY():new ByYThenX()));
			if (points.get(0).get(myDim)==points.get(points.size()-1).get(myDim)) {
				//degenerate nodes in a line
				myDim = myDim==0?1:0; //switch cutting dimension
			}
			
			double myVal = (cell.getHigh().get(myDim)+cell.getLow().get(myDim))/2;
			if (myVal<points.get(0).get(myDim)) {
				myVal = points.get(0).get(myDim); //slide midpoint
			} else if (myVal>points.get(points.size()-1).get(myDim)) {
				myVal = points.get(points.size()-1).get(myDim); //slide midpoint
			}
			
			//seperate points into new lists
			ArrayList<LPoint> leftPoints = new ArrayList<LPoint>();
			ArrayList<LPoint> rightPoints = new ArrayList<LPoint>();
			for (int i = 0; i < points.size(); i++) {
				if (points.get(i).get(myDim)<myVal) {
					leftPoints.add(points.get(i));
				} else {
					rightPoints.add(points.get(i));
				}
			}
			
			
			Rectangle2D lcell = new Rectangle2D(cell.low,
						(myDim==0?new Point2D(myVal,cell.high.get(myDim==0?1:0))
								:new Point2D(cell.high.get(myDim==0?1:0),myVal)));
			Rectangle2D rcell = new Rectangle2D((myDim==0? 
					new Point2D(myVal,cell.low.get(myDim==0?1:0))
					:new Point2D(cell.low.get(myDim==0?1:0),myVal)),
					cell.high);
			
		
			
			InternalNode returnNode = new InternalNode(myDim, myVal, cell);
			returnNode.left = bulkCreate(leftPoints,lcell);
			returnNode.right = bulkCreate(rightPoints,rcell);
			returnNode.size = points.size();
			
			return returnNode;
			
		}
		
		
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			temp.addAll(left.getPointList());
			temp.addAll(right.getPointList());
			return temp;
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (pt.get(cutDim)<cutVal) {
				left = left.insertNode(pt, cutDim==0?(new Rectangle2D(this.cell.low,
						new Point2D(cutVal,this.cell.high.getY()))):
							(new Rectangle2D(this.cell.low,
									new Point2D(this.cell.high.getX(),cutVal))));
				
			} else {
				right = right.insertNode(pt, cutDim==0?(new Rectangle2D(
						new Point2D(cutVal,this.cell.low.getY()),this.cell.high)):
							(new Rectangle2D(new Point2D(this.cell.low.getX(),cutVal)
									,this.cell.high)));
				
			}
			size++;
			insertionCounter++;
			if (insertionCounter > (size + REBUILDOFFSET)/2) {
				return bulkCreate(getPointList(),cell);
			} else {
				return this;
			}
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			if (cutDim==0)
				retVal.add("(x=" + cutVal + ") " + size + ":" + insertionCounter);
			else
				retVal.add("(y=" + cutVal + ") " + size + ":" + insertionCounter);
			retVal.addAll(right.listNodes());
			retVal.addAll(left.listNodes());
			return retVal;
		}
	}
	
	private class ExternalNode extends Node {
		LPoint point;
		
		void addCenter(LPoint center) {
			
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (point == null) {
				return bestPoint;
			}
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			if(bestPoint.size()==0 ) {
				bestPoint.add(point);
			} else if (bestPoint.get(0).getPoint2D().distance(center)>=point.getPoint2D().distance(center)) {
				if(bestPoint.get(0).getPoint2D().distance(center)==point.getPoint2D().distance(center)) {
					if (bestPoint.get(0).getX()>point.getX()) {
						bestPoint.add(0, point);
					} else if (bestPoint.get(0).getX()==point.getX() &&
							bestPoint.get(0).getY()>point.getY()) {
						//new best point because of lower lexicographic score
						bestPoint.add(0, point);
					} else {
						bestPoint.add(point);
					}
				} else {
					//must be a best point because dist is less than old best
					bestPoint.add(0, point);
				}
			} else {
				bestPoint.add(point);
			}
			return bestPoint;
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception {
			//will only ever be called on a tree of size 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			} 
			return new ExternalNode(points.get(0));
		}
		
		Node deleteNode(Point2D pt) {
			if (point == null) {
				return null;
			} else if (point.getPoint2D().equals(pt)) {
				point = null;
				return this;
			} else {
				return null;
			}
		}
		
		int size() { return point==null?0:1; }
		
		public String toString() {
			if (point != null)
				return "("+point.getX()+", "+point.getY()+") ";
			else
				return "null point";
		}
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			if (point!=null) {
				temp.add(point);
			}
			return temp;
		}
		
		ExternalNode(LPoint point) {
			this.point = point;
		}
		
		boolean inNode() { return false; }
		
		LPoint leftMostPoint() { return point; }
		
		LPoint findNode(Point2D q) {
			if (point == null) {
				return null;
			}
			if (point.getPoint2D().equals(q)) {
				return point;
			} else {
				return null;
			}
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (point == null) {
				point = pt;
				return this;
			}
			if (point.getPoint2D().equals(pt.getPoint2D())) {
				throw new Exception("Insertion of duplicate point");
			}
			//find cutDim
			int cutDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			if (pt.get(cutDim)==point.get(cutDim)) {
				cutDim = cutDim==0?1:0; //if x is cutDim and x's are equal make
				//cutDim Y and vice versa
			}
			
			//find our cutVal
			double cutVal = (cell.high.get(cutDim)+cell.low.get(cutDim))/2;
			double pointVal = point.get(cutDim);
			double ptVal = pt.get(cutDim);
			if (cutVal>pointVal && cutVal>ptVal) {
				cutVal = pointVal>ptVal?pointVal:ptVal;
			} else if (cutVal<pointVal && cutVal<ptVal) {
				cutVal = pointVal<ptVal?pointVal:ptVal;
			}
			
			//create our new internal node
			InternalNode node = new InternalNode(cutDim, cutVal, cell);
			//add our external nodes
			node.insertNode(pt, cell);
			node.insertNode(point, cell);
			node.insertionCounter = 0;
			return node;
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			retVal.add("["+(point==null?"null":point.toString()) + "]");
			return retVal;
		}

		
	}
	
	public SMkdTreeMe(int rebuildOffset, Rectangle2D rootCell) { 
		REBUILDOFFSET = rebuildOffset;
		this.rootCell = rootCell;
		root = new ExternalNode(null);
		deleteCount = 0;
	}
	public void clear() { root = new ExternalNode(null); }
	public int size() { return root==null?0:root.size(); }
	public int deleteCount() { return deleteCount; }
	public LPoint find(Point2D q) { return root.findNode(q); }
	public void insert(LPoint pt) throws Exception { 
		if (!rootCell.contains(pt.getPoint2D()))
			throw new Exception("Attempt to insert a point outside bounding box");
		root = root.insertNode(pt, rootCell);
	}
	public void delete(Point2D pt) throws Exception { 
		Node node = root.deleteNode(pt);
		if (node == null) {
			throw new Exception("Deletion of nonexistent point");
		} else {
			deleteCount++;
			if (deleteCount>size()) {
				root = root.bulkCreate(root.getPointList(),rootCell);
				deleteCount = 0;
			}
		}
	}
	public ArrayList<String> list() { return root.listNodes(); }
	public LPoint nearestNeighbor(Point2D center) { 
		if (size()==0) 
			return null;
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		return points.get(0);
	}
	public ArrayList<LPoint> nearestNeighborVisit(Point2D center) { 
		if (size()==0) 
			return new ArrayList<LPoint>();
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		Collections.sort(points, new ByXThenY());
		return points;
	}

	public String toString() {
		return root.toString();
	}
	
	
	// ----------------------------------------------------------------
	// Possible new additions for Programming Assignment 3
	// You may modify/add/remove these as you see fit, since they will 
	// just be used internally by your code.
	// ----------------------------------------------------------------
	void addCenter(LPoint center) { 
		root.addCenter(center);
	}
	// ArrayList<String> listWithCenters() { /* ... */ return null; }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-17 14:29:28.471
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-17 14:29:28.472
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-05-17 14:29:30.430
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package cmsc420_s23;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;

public class SMkdTreeMe<LPoint extends LabeledPoint2D> {
		
	private final int REBUILDOFFSET;
	private Rectangle2D rootCell;
	private Node root;
	private int deleteCount;
	
	private abstract class Node {
		private LinkedList<LPoint> contenders;
		abstract LPoint findNode(Point2D q);
		abstract Node insertNode(LPoint pt, Rectangle2D cell) throws Exception;
		abstract Node deleteNode(Point2D pt);
		abstract int size();
		abstract boolean inNode();
		abstract LPoint leftMostPoint();
		abstract ArrayList<String> listNodes();
		abstract ArrayList<LPoint> getPointList();
		public String toString() {
			return "";
		}
		abstract void addCenter(LPoint center);
		abstract ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint);
		abstract Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception;
	}
	
	private class ByXThenY implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(0)!=pt2.get(0)) {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			} else {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			}
		}
	}
	private class ByYThenX implements Comparator<LPoint> {
		public int compare(LPoint pt1, LPoint pt2) {
			if (pt1.get(1)!=pt2.get(1)) {
				return pt1.get(1)-pt2.get(1)>0?1:-1;
			} else {
				return pt1.get(0)-pt2.get(0)>0?1:-1;
			}
		}
	}
	
	public double min4(double a, double b, double c, double d) {
		return (a<b):((a<c):())?()
	}
	
	private class InternalNode extends Node {
		int cutDim;
		double cutVal;
		Node left, right;
		int size; //n counter from slides (Lect12)
		int insertionCounter; //m counter from slides (Lect12)
		Rectangle2D cell;
		double rMin;
		
		void addCenter(LPoint center) {
			if (cell.contains(center.getPoint2D())) {
				double tempMin;
			}
				
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			
			//create cells based on value of cutDim
			Rectangle2D lcell = new Rectangle2D(cell.low,
					(cutDim==0?new Point2D(cutVal,cell.high.get(cutDim==0?1:0))
							:new Point2D(cell.high.get(cutDim==0?1:0),cutVal)));
			Rectangle2D rcell = new Rectangle2D((cutDim==0? 
					new Point2D(cutVal,cell.low.get(cutDim==0?1:0))
							:new Point2D(cell.low.get(cutDim==0?1:0),cutVal)),
									cell.high);
			
			
			if (bestPoint.size() == 0) {
				// if size == 0 we must call nearestNeighbor on one subtree 
				// and then potentially on the other
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					bestPoint = left.nearestNeighborNode(center, bestPoint);//rec1 //rec4
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
					}
				} else {
					bestPoint = right.nearestNeighborNode(center, bestPoint);//rec2 //rec3
					if (bestPoint.size()==0 || 
							bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						//System.out.println("arrived 2 at cutDim: " + cutDim + " and cutVal: " + cutVal);
						bestPoint = left.nearestNeighborNode(center, bestPoint);
					}
				}
			} else {
				// if size != 0 we might need to call nearestNeighbor on one
				// subtree and if so maybe on the other as well
				if (lcell.distanceSq(center)<=rcell.distanceSq(center)) {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
						bestPoint = left.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
							bestPoint = right.nearestNeighborNode(center, bestPoint);
						}
					}
				} else {
					if(bestPoint.get(0).getPoint2D().distanceSq(center)>rcell.distanceSq(center)) {
						bestPoint = right.nearestNeighborNode(center, bestPoint);
						if (bestPoint.get(0).getPoint2D().distanceSq(center)>=lcell.distanceSq(center)) {
							bestPoint = left.nearestNeighborNode(center, bestPoint);
						}
					}
				}
			}
			return bestPoint;
			
			
			
		}
		
		Node deleteNode(Point2D pt) {
			if (pt.get(cutDim)<cutVal) {
				Node node = left.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			} else {
				Node node = right.deleteNode(pt);
				if (node!=null)
					size--;
				return node;
			}
		}
		
		public String toString() {
			return "{"+left.toString() + "\n[Cut Dim: "+cutDim+"  Cut Val: "+cutVal+
					"   Size: "+size+"   Insertions: "+insertionCounter+"]\n"+
					right.toString()+"}";
		}
		
		boolean inNode() { return true; }
		
		LPoint leftMostPoint() { return left.leftMostPoint(); }
		
		public InternalNode(int cutDim, double cutVal, Rectangle2D cell) {
			this.cutDim = cutDim;
			this.cutVal = cutVal;
			size = 0;
			insertionCounter = 0;
			this.cell = cell;
			this.left = new ExternalNode(null);
			this.right = new ExternalNode(null);
		}
		
		int size() { return size; }
		
		LPoint findNode(Point2D q) {
			if (q.get(cutDim)<cutVal) {
				return left.findNode(q);
			} else {
				return right.findNode(q);
			}
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) {
			//create externalNode if size == 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			}
			if (points.size()==1) {
				return new ExternalNode(points.get(0));
			}
			
			//otherwise have to split into two new cells
			int myDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			Collections.sort(points, (myDim==0?new ByXThenY():new ByYThenX()));
			if (points.get(0).get(myDim)==points.get(points.size()-1).get(myDim)) {
				//degenerate nodes in a line
				myDim = myDim==0?1:0; //switch cutting dimension
			}
			
			double myVal = (cell.getHigh().get(myDim)+cell.getLow().get(myDim))/2;
			if (myVal<points.get(0).get(myDim)) {
				myVal = points.get(0).get(myDim); //slide midpoint
			} else if (myVal>points.get(points.size()-1).get(myDim)) {
				myVal = points.get(points.size()-1).get(myDim); //slide midpoint
			}
			
			//seperate points into new lists
			ArrayList<LPoint> leftPoints = new ArrayList<LPoint>();
			ArrayList<LPoint> rightPoints = new ArrayList<LPoint>();
			for (int i = 0; i < points.size(); i++) {
				if (points.get(i).get(myDim)<myVal) {
					leftPoints.add(points.get(i));
				} else {
					rightPoints.add(points.get(i));
				}
			}
			
			
			Rectangle2D lcell = new Rectangle2D(cell.low,
						(myDim==0?new Point2D(myVal,cell.high.get(myDim==0?1:0))
								:new Point2D(cell.high.get(myDim==0?1:0),myVal)));
			Rectangle2D rcell = new Rectangle2D((myDim==0? 
					new Point2D(myVal,cell.low.get(myDim==0?1:0))
					:new Point2D(cell.low.get(myDim==0?1:0),myVal)),
					cell.high);
			
		
			
			InternalNode returnNode = new InternalNode(myDim, myVal, cell);
			returnNode.left = bulkCreate(leftPoints,lcell);
			returnNode.right = bulkCreate(rightPoints,rcell);
			returnNode.size = points.size();
			
			return returnNode;
			
		}
		
		
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			temp.addAll(left.getPointList());
			temp.addAll(right.getPointList());
			return temp;
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (pt.get(cutDim)<cutVal) {
				left = left.insertNode(pt, cutDim==0?(new Rectangle2D(this.cell.low,
						new Point2D(cutVal,this.cell.high.getY()))):
							(new Rectangle2D(this.cell.low,
									new Point2D(this.cell.high.getX(),cutVal))));
				
			} else {
				right = right.insertNode(pt, cutDim==0?(new Rectangle2D(
						new Point2D(cutVal,this.cell.low.getY()),this.cell.high)):
							(new Rectangle2D(new Point2D(this.cell.low.getX(),cutVal)
									,this.cell.high)));
				
			}
			size++;
			insertionCounter++;
			if (insertionCounter > (size + REBUILDOFFSET)/2) {
				return bulkCreate(getPointList(),cell);
			} else {
				return this;
			}
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			if (cutDim==0)
				retVal.add("(x=" + cutVal + ") " + size + ":" + insertionCounter);
			else
				retVal.add("(y=" + cutVal + ") " + size + ":" + insertionCounter);
			retVal.addAll(right.listNodes());
			retVal.addAll(left.listNodes());
			return retVal;
		}
	}
	
	private class ExternalNode extends Node {
		LPoint point;
		
		void addCenter(LPoint center) {
			
		}
		
		ArrayList<LPoint> nearestNeighborNode(Point2D center, ArrayList<LPoint> bestPoint) {
			if (point == null) {
				return bestPoint;
			}
			if (bestPoint == null) {
				bestPoint = new ArrayList<LPoint>();
			}
			if(bestPoint.size()==0 ) {
				bestPoint.add(point);
			} else if (bestPoint.get(0).getPoint2D().distance(center)>=point.getPoint2D().distance(center)) {
				if(bestPoint.get(0).getPoint2D().distance(center)==point.getPoint2D().distance(center)) {
					if (bestPoint.get(0).getX()>point.getX()) {
						bestPoint.add(0, point);
					} else if (bestPoint.get(0).getX()==point.getX() &&
							bestPoint.get(0).getY()>point.getY()) {
						//new best point because of lower lexicographic score
						bestPoint.add(0, point);
					} else {
						bestPoint.add(point);
					}
				} else {
					//must be a best point because dist is less than old best
					bestPoint.add(0, point);
				}
			} else {
				bestPoint.add(point);
			}
			return bestPoint;
		}
		
		Node bulkCreate(ArrayList<LPoint> points, Rectangle2D cell) throws Exception {
			//will only ever be called on a tree of size 0 or 1
			if (points.size()==0) {
				return new ExternalNode(null);
			} 
			return new ExternalNode(points.get(0));
		}
		
		Node deleteNode(Point2D pt) {
			if (point == null) {
				return null;
			} else if (point.getPoint2D().equals(pt)) {
				point = null;
				return this;
			} else {
				return null;
			}
		}
		
		int size() { return point==null?0:1; }
		
		public String toString() {
			if (point != null)
				return "("+point.getX()+", "+point.getY()+") ";
			else
				return "null point";
		}
		
		ArrayList<LPoint> getPointList() {
			ArrayList<LPoint> temp = new ArrayList<LPoint>();
			if (point!=null) {
				temp.add(point);
			}
			return temp;
		}
		
		ExternalNode(LPoint point) {
			this.point = point;
		}
		
		boolean inNode() { return false; }
		
		LPoint leftMostPoint() { return point; }
		
		LPoint findNode(Point2D q) {
			if (point == null) {
				return null;
			}
			if (point.getPoint2D().equals(q)) {
				return point;
			} else {
				return null;
			}
		}
		
		Node insertNode(LPoint pt, Rectangle2D cell) throws Exception {
			
			if (point == null) {
				point = pt;
				return this;
			}
			if (point.getPoint2D().equals(pt.getPoint2D())) {
				throw new Exception("Insertion of duplicate point");
			}
			//find cutDim
			int cutDim = cell.getWidth(0)>=cell.getWidth(1)?0:1;
			if (pt.get(cutDim)==point.get(cutDim)) {
				cutDim = cutDim==0?1:0; //if x is cutDim and x's are equal make
				//cutDim Y and vice versa
			}
			
			//find our cutVal
			double cutVal = (cell.high.get(cutDim)+cell.low.get(cutDim))/2;
			double pointVal = point.get(cutDim);
			double ptVal = pt.get(cutDim);
			if (cutVal>pointVal && cutVal>ptVal) {
				cutVal = pointVal>ptVal?pointVal:ptVal;
			} else if (cutVal<pointVal && cutVal<ptVal) {
				cutVal = pointVal<ptVal?pointVal:ptVal;
			}
			
			//create our new internal node
			InternalNode node = new InternalNode(cutDim, cutVal, cell);
			//add our external nodes
			node.insertNode(pt, cell);
			node.insertNode(point, cell);
			node.insertionCounter = 0;
			return node;
		}

		ArrayList<String> listNodes() {
			ArrayList<String> retVal = new ArrayList<String>();
			retVal.add("["+(point==null?"null":point.toString()) + "]");
			return retVal;
		}

		
	}
	
	public SMkdTreeMe(int rebuildOffset, Rectangle2D rootCell) { 
		REBUILDOFFSET = rebuildOffset;
		this.rootCell = rootCell;
		root = new ExternalNode(null);
		deleteCount = 0;
	}
	public void clear() { root = new ExternalNode(null); }
	public int size() { return root==null?0:root.size(); }
	public int deleteCount() { return deleteCount; }
	public LPoint find(Point2D q) { return root.findNode(q); }
	public void insert(LPoint pt) throws Exception { 
		if (!rootCell.contains(pt.getPoint2D()))
			throw new Exception("Attempt to insert a point outside bounding box");
		root = root.insertNode(pt, rootCell);
	}
	public void delete(Point2D pt) throws Exception { 
		Node node = root.deleteNode(pt);
		if (node == null) {
			throw new Exception("Deletion of nonexistent point");
		} else {
			deleteCount++;
			if (deleteCount>size()) {
				root = root.bulkCreate(root.getPointList(),rootCell);
				deleteCount = 0;
			}
		}
	}
	public ArrayList<String> list() { return root.listNodes(); }
	public LPoint nearestNeighbor(Point2D center) { 
		if (size()==0) 
			return null;
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		return points.get(0);
	}
	public ArrayList<LPoint> nearestNeighborVisit(Point2D center) { 
		if (size()==0) 
			return new ArrayList<LPoint>();
		ArrayList<LPoint> points = root.nearestNeighborNode(center, null); 
		Collections.sort(points, new ByXThenY());
		return points;
	}

	public String toString() {
		return root.toString();
	}
	
	
	// ----------------------------------------------------------------
	// Possible new additions for Programming Assignment 3
	// You may modify/add/remove these as you see fit, since they will 
	// just be used internally by your code.
	// ----------------------------------------------------------------
	void addCenter(LPoint center) { 
		root.addCenter(center);
	}
	// ArrayList<String> listWithCenters() { /* ... */ return null; }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-05-17 14:29:30.434
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-05-17 14:29:30.436
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.debug.ui 4 120 2023-05-17 17:27:54.965
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-05-17 17:30:33.800
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.debug.ui 4 120 2023-05-17 17:49:01.010
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2024-03-04 19:59:36.437 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.2
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2024-03-04 19:59:54.589
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-03-04 19:59:54.589
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@115ef673,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8ce3f27,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-03-04 20:00:13.311
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\kgj'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2024-03-04 20:00:14.126
!MESSAGE The org.eclipse.ui.IStartup extension from 'edu.umd.cs.eclipse.courseProjectManager' does not provide a valid 'startup' element.
